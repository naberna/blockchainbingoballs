{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Secp256k1HdWallet = exports.extractKdfConfiguration = void 0;\n\nconst crypto_1 = require(\"@cosmjs/crypto\");\n\nconst encoding_1 = require(\"@cosmjs/encoding\");\n\nconst utils_1 = require(\"@cosmjs/utils\");\n\nconst addresses_1 = require(\"./addresses\");\n\nconst paths_1 = require(\"./paths\");\n\nconst signature_1 = require(\"./signature\");\n\nconst signdoc_1 = require(\"./signdoc\");\n\nconst wallet_1 = require(\"./wallet\");\n\nconst serializationTypeV1 = \"secp256k1wallet-v1\";\n/**\n * A KDF configuration that is not very strong but can be used on the main thread.\n * It takes about 1 second in Node.js 16.0.0 and should have similar runtimes in other modern Wasm hosts.\n */\n\nconst basicPasswordHashingOptions = {\n  algorithm: \"argon2id\",\n  params: {\n    outputLength: 32,\n    opsLimit: 24,\n    memLimitKib: 12 * 1024\n  }\n};\n\nfunction isDerivationJson(thing) {\n  if (!(0, utils_1.isNonNullObject)(thing)) return false;\n  if (typeof thing.hdPath !== \"string\") return false;\n  if (typeof thing.prefix !== \"string\") return false;\n  return true;\n}\n\nfunction extractKdfConfigurationV1(doc) {\n  return doc.kdf;\n}\n\nfunction extractKdfConfiguration(serialization) {\n  const root = JSON.parse(serialization);\n  if (!(0, utils_1.isNonNullObject)(root)) throw new Error(\"Root document is not an object.\");\n\n  switch (root.type) {\n    case serializationTypeV1:\n      return extractKdfConfigurationV1(root);\n\n    default:\n      throw new Error(\"Unsupported serialization type\");\n  }\n}\n\nexports.extractKdfConfiguration = extractKdfConfiguration;\nconst defaultOptions = {\n  bip39Password: \"\",\n  hdPaths: [(0, paths_1.makeCosmoshubPath)(0)],\n  prefix: \"cosmos\"\n};\n\nclass Secp256k1HdWallet {\n  constructor(mnemonic, options) {\n    var _a, _b;\n\n    const hdPaths = (_a = options.hdPaths) !== null && _a !== void 0 ? _a : defaultOptions.hdPaths;\n    const prefix = (_b = options.prefix) !== null && _b !== void 0 ? _b : defaultOptions.prefix;\n    this.secret = mnemonic;\n    this.seed = options.seed;\n    this.accounts = hdPaths.map(hdPath => ({\n      hdPath: hdPath,\n      prefix\n    }));\n  }\n  /**\n   * Restores a wallet from the given BIP39 mnemonic.\n   *\n   * @param mnemonic Any valid English mnemonic.\n   * @param options An optional `Secp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.\n   */\n\n\n  static async fromMnemonic(mnemonic) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const mnemonicChecked = new crypto_1.EnglishMnemonic(mnemonic);\n    const seed = await crypto_1.Bip39.mnemonicToSeed(mnemonicChecked, options.bip39Password);\n    return new Secp256k1HdWallet(mnemonicChecked, { ...options,\n      seed: seed\n    });\n  }\n  /**\n   * Generates a new wallet with a BIP39 mnemonic of the given length.\n   *\n   * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).\n   * @param options An optional `Secp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.\n   */\n\n\n  static async generate() {\n    let length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 12;\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const entropyLength = 4 * Math.floor(11 * length / 33);\n    const entropy = crypto_1.Random.getBytes(entropyLength);\n    const mnemonic = crypto_1.Bip39.encode(entropy);\n    return Secp256k1HdWallet.fromMnemonic(mnemonic.toString(), options);\n  }\n  /**\n   * Restores a wallet from an encrypted serialization.\n   *\n   * @param password The user provided password used to generate an encryption key via a KDF.\n   *                 This is not normalized internally (see \"Unicode normalization\" to learn more).\n   */\n\n\n  static async deserialize(serialization, password) {\n    const root = JSON.parse(serialization);\n    if (!(0, utils_1.isNonNullObject)(root)) throw new Error(\"Root document is not an object.\");\n\n    switch (root.type) {\n      case serializationTypeV1:\n        return Secp256k1HdWallet.deserializeTypeV1(serialization, password);\n\n      default:\n        throw new Error(\"Unsupported serialization type\");\n    }\n  }\n  /**\n   * Restores a wallet from an encrypted serialization.\n   *\n   * This is an advanced alternative to calling `deserialize(serialization, password)` directly, which allows\n   * you to offload the KDF execution to a non-UI thread (e.g. in a WebWorker).\n   *\n   * The caller is responsible for ensuring the key was derived with the given KDF configuration. This can be\n   * done using `extractKdfConfiguration(serialization)` and `executeKdf(password, kdfConfiguration)` from this package.\n   */\n\n\n  static async deserializeWithEncryptionKey(serialization, encryptionKey) {\n    const root = JSON.parse(serialization);\n    if (!(0, utils_1.isNonNullObject)(root)) throw new Error(\"Root document is not an object.\");\n    const untypedRoot = root;\n\n    switch (untypedRoot.type) {\n      case serializationTypeV1:\n        {\n          const decryptedBytes = await (0, wallet_1.decrypt)((0, encoding_1.fromBase64)(untypedRoot.data), encryptionKey, untypedRoot.encryption);\n          const decryptedDocument = JSON.parse((0, encoding_1.fromUtf8)(decryptedBytes));\n          const {\n            mnemonic,\n            accounts\n          } = decryptedDocument;\n          (0, utils_1.assert)(typeof mnemonic === \"string\");\n          if (!Array.isArray(accounts)) throw new Error(\"Property 'accounts' is not an array\");\n\n          if (!accounts.every(account => isDerivationJson(account))) {\n            throw new Error(\"Account is not in the correct format.\");\n          }\n\n          const firstPrefix = accounts[0].prefix;\n\n          if (!accounts.every(_ref => {\n            let {\n              prefix\n            } = _ref;\n            return prefix === firstPrefix;\n          })) {\n            throw new Error(\"Accounts do not all have the same prefix\");\n          }\n\n          const hdPaths = accounts.map(_ref2 => {\n            let {\n              hdPath\n            } = _ref2;\n            return (0, crypto_1.stringToPath)(hdPath);\n          });\n          return Secp256k1HdWallet.fromMnemonic(mnemonic, {\n            hdPaths: hdPaths,\n            prefix: firstPrefix\n          });\n        }\n\n      default:\n        throw new Error(\"Unsupported serialization type\");\n    }\n  }\n\n  static async deserializeTypeV1(serialization, password) {\n    const root = JSON.parse(serialization);\n    if (!(0, utils_1.isNonNullObject)(root)) throw new Error(\"Root document is not an object.\");\n    const encryptionKey = await (0, wallet_1.executeKdf)(password, root.kdf);\n    return Secp256k1HdWallet.deserializeWithEncryptionKey(serialization, encryptionKey);\n  }\n\n  get mnemonic() {\n    return this.secret.toString();\n  }\n\n  async getAccounts() {\n    const accountsWithPrivkeys = await this.getAccountsWithPrivkeys();\n    return accountsWithPrivkeys.map(_ref3 => {\n      let {\n        algo,\n        pubkey,\n        address\n      } = _ref3;\n      return {\n        algo: algo,\n        pubkey: pubkey,\n        address: address\n      };\n    });\n  }\n\n  async signAmino(signerAddress, signDoc) {\n    const accounts = await this.getAccountsWithPrivkeys();\n    const account = accounts.find(_ref4 => {\n      let {\n        address\n      } = _ref4;\n      return address === signerAddress;\n    });\n\n    if (account === undefined) {\n      throw new Error(`Address ${signerAddress} not found in wallet`);\n    }\n\n    const {\n      privkey,\n      pubkey\n    } = account;\n    const message = (0, crypto_1.sha256)((0, signdoc_1.serializeSignDoc)(signDoc));\n    const signature = await crypto_1.Secp256k1.createSignature(message, privkey);\n    const signatureBytes = new Uint8Array([...signature.r(32), ...signature.s(32)]);\n    return {\n      signed: signDoc,\n      signature: (0, signature_1.encodeSecp256k1Signature)(pubkey, signatureBytes)\n    };\n  }\n  /**\n   * Generates an encrypted serialization of this wallet.\n   *\n   * @param password The user provided password used to generate an encryption key via a KDF.\n   *                 This is not normalized internally (see \"Unicode normalization\" to learn more).\n   */\n\n\n  async serialize(password) {\n    const kdfConfiguration = basicPasswordHashingOptions;\n    const encryptionKey = await (0, wallet_1.executeKdf)(password, kdfConfiguration);\n    return this.serializeWithEncryptionKey(encryptionKey, kdfConfiguration);\n  }\n  /**\n   * Generates an encrypted serialization of this wallet.\n   *\n   * This is an advanced alternative to calling `serialize(password)` directly, which allows you to\n   * offload the KDF execution to a non-UI thread (e.g. in a WebWorker).\n   *\n   * The caller is responsible for ensuring the key was derived with the given KDF options. If this\n   * is not the case, the wallet cannot be restored with the original password.\n   */\n\n\n  async serializeWithEncryptionKey(encryptionKey, kdfConfiguration) {\n    const dataToEncrypt = {\n      mnemonic: this.mnemonic,\n      accounts: this.accounts.map(_ref5 => {\n        let {\n          hdPath,\n          prefix\n        } = _ref5;\n        return {\n          hdPath: (0, crypto_1.pathToString)(hdPath),\n          prefix: prefix\n        };\n      })\n    };\n    const dataToEncryptRaw = (0, encoding_1.toUtf8)(JSON.stringify(dataToEncrypt));\n    const encryptionConfiguration = {\n      algorithm: wallet_1.supportedAlgorithms.xchacha20poly1305Ietf\n    };\n    const encryptedData = await (0, wallet_1.encrypt)(dataToEncryptRaw, encryptionKey, encryptionConfiguration);\n    const out = {\n      type: serializationTypeV1,\n      kdf: kdfConfiguration,\n      encryption: encryptionConfiguration,\n      data: (0, encoding_1.toBase64)(encryptedData)\n    };\n    return JSON.stringify(out);\n  }\n\n  async getKeyPair(hdPath) {\n    const {\n      privkey\n    } = crypto_1.Slip10.derivePath(crypto_1.Slip10Curve.Secp256k1, this.seed, hdPath);\n    const {\n      pubkey\n    } = await crypto_1.Secp256k1.makeKeypair(privkey);\n    return {\n      privkey: privkey,\n      pubkey: crypto_1.Secp256k1.compressPubkey(pubkey)\n    };\n  }\n\n  async getAccountsWithPrivkeys() {\n    return Promise.all(this.accounts.map(async _ref6 => {\n      let {\n        hdPath,\n        prefix\n      } = _ref6;\n      const {\n        privkey,\n        pubkey\n      } = await this.getKeyPair(hdPath);\n      const address = (0, encoding_1.toBech32)(prefix, (0, addresses_1.rawSecp256k1PubkeyToRawAddress)(pubkey));\n      return {\n        algo: \"secp256k1\",\n        privkey: privkey,\n        pubkey: pubkey,\n        address: address\n      };\n    }));\n  }\n\n}\n\nexports.Secp256k1HdWallet = Secp256k1HdWallet;","map":{"version":3,"mappings":"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","names":["serializationTypeV1","basicPasswordHashingOptions","algorithm","params","outputLength","opsLimit","memLimitKib","isDerivationJson","thing","hdPath","prefix","extractKdfConfigurationV1","doc","kdf","extractKdfConfiguration","serialization","root","JSON","parse","Error","type","exports","defaultOptions","bip39Password","hdPaths","Secp256k1HdWallet","constructor","mnemonic","options","_a","_b","secret","seed","accounts","map","fromMnemonic","mnemonicChecked","crypto_1","mnemonicToSeed","generate","length","entropyLength","Math","floor","entropy","getBytes","encode","toString","deserialize","password","deserializeTypeV1","deserializeWithEncryptionKey","encryptionKey","untypedRoot","decryptedBytes","data","encryption","decryptedDocument","Array","isArray","every","account","firstPrefix","getAccounts","accountsWithPrivkeys","getAccountsWithPrivkeys","algo","pubkey","address","signAmino","signerAddress","signDoc","find","undefined","privkey","message","signature","createSignature","signatureBytes","Uint8Array","r","s","signed","serialize","kdfConfiguration","serializeWithEncryptionKey","dataToEncrypt","dataToEncryptRaw","stringify","encryptionConfiguration","wallet_1","xchacha20poly1305Ietf","encryptedData","out","getKeyPair","derivePath","Secp256k1","makeKeypair","compressPubkey","Promise","all"],"sourceRoot":"","sources":["../src/secp256k1hdwallet.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}