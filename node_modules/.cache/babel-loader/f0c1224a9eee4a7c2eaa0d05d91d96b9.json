{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.QueryClient = void 0;\n/* eslint-disable no-dupe-class-members, @typescript-eslint/ban-types, @typescript-eslint/naming-convention */\n\nconst ics23_1 = require(\"@confio/ics23\");\n\nconst encoding_1 = require(\"@cosmjs/encoding\");\n\nconst stream_1 = require(\"@cosmjs/stream\");\n\nconst utils_1 = require(\"@cosmjs/utils\");\n\nfunction checkAndParseOp(op, kind, key) {\n  if (op.type !== kind) {\n    throw new Error(`Op expected to be ${kind}, got \"${op.type}`);\n  }\n\n  if (!(0, utils_1.arrayContentEquals)(key, op.key)) {\n    throw new Error(`Proven key different than queried key.\\nQuery: ${(0, encoding_1.toHex)(key)}\\nProven: ${(0, encoding_1.toHex)(op.key)}`);\n  }\n\n  return ics23_1.ics23.CommitmentProof.decode(op.data);\n}\n\nclass QueryClient {\n  constructor(tmClient) {\n    this.tmClient = tmClient;\n  }\n\n  static withExtensions(tmClient) {\n    const client = new QueryClient(tmClient);\n\n    for (var _len = arguments.length, extensionSetups = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      extensionSetups[_key - 1] = arguments[_key];\n    }\n\n    const extensions = extensionSetups.map(setupExtension => setupExtension(client));\n\n    for (const extension of extensions) {\n      (0, utils_1.assert)((0, utils_1.isNonNullObject)(extension), `Extension must be a non-null object`);\n\n      for (const [moduleKey, moduleValue] of Object.entries(extension)) {\n        (0, utils_1.assert)((0, utils_1.isNonNullObject)(moduleValue), `Module must be a non-null object. Found type ${typeof moduleValue} for module \"${moduleKey}\".`);\n        const current = client[moduleKey] || {};\n        client[moduleKey] = { ...current,\n          ...moduleValue\n        };\n      }\n    }\n\n    return client;\n  }\n\n  async queryVerified(store, key, desiredHeight) {\n    const {\n      height,\n      proof,\n      value\n    } = await this.queryRawProof(store, key, desiredHeight);\n    const subProof = checkAndParseOp(proof.ops[0], \"ics23:iavl\", key);\n    const storeProof = checkAndParseOp(proof.ops[1], \"ics23:simple\", (0, encoding_1.toAscii)(store)); // this must always be existence, if the store is not a typo\n\n    (0, utils_1.assert)(storeProof.exist);\n    (0, utils_1.assert)(storeProof.exist.value); // this may be exist or non-exist, depends on response\n\n    if (!value || value.length === 0) {\n      // non-existence check\n      (0, utils_1.assert)(subProof.nonexist); // the subproof must map the desired key to the \"value\" of the storeProof\n\n      (0, ics23_1.verifyNonExistence)(subProof.nonexist, ics23_1.iavlSpec, storeProof.exist.value, key);\n    } else {\n      // existence check\n      (0, utils_1.assert)(subProof.exist);\n      (0, utils_1.assert)(subProof.exist.value); // the subproof must map the desired key to the \"value\" of the storeProof\n\n      (0, ics23_1.verifyExistence)(subProof.exist, ics23_1.iavlSpec, storeProof.exist.value, key, value);\n    } // the store proof must map its declared value (root of subProof) to the appHash of the next block\n\n\n    const header = await this.getNextHeader(height);\n    (0, ics23_1.verifyExistence)(storeProof.exist, ics23_1.tendermintSpec, header.appHash, (0, encoding_1.toAscii)(store), storeProof.exist.value);\n    return value;\n  }\n\n  async queryRawProof(store, queryKey, desiredHeight) {\n    var _a;\n\n    const {\n      key,\n      value,\n      height,\n      proof,\n      code,\n      log\n    } = await this.tmClient.abciQuery({\n      // we need the StoreKey for the module, not the module name\n      // https://github.com/cosmos/cosmos-sdk/blob/8cab43c8120fec5200c3459cbf4a92017bb6f287/x/auth/types/keys.go#L12\n      path: `/store/${store}/key`,\n      data: queryKey,\n      prove: true,\n      height: desiredHeight\n    });\n\n    if (code) {\n      throw new Error(`Query failed with (${code}): ${log}`);\n    }\n\n    if (!(0, utils_1.arrayContentEquals)(queryKey, key)) {\n      throw new Error(`Response key ${(0, encoding_1.toHex)(key)} doesn't match query key ${(0, encoding_1.toHex)(queryKey)}`);\n    }\n\n    if (!height) {\n      throw new Error(\"No query height returned\");\n    }\n\n    if (!proof || proof.ops.length !== 2) {\n      throw new Error(`Expected 2 proof ops, got ${(_a = proof === null || proof === void 0 ? void 0 : proof.ops.length) !== null && _a !== void 0 ? _a : 0}. Are you using stargate?`);\n    } // we don't need the results, but we can ensure the data is the proper format\n\n\n    checkAndParseOp(proof.ops[0], \"ics23:iavl\", key);\n    checkAndParseOp(proof.ops[1], \"ics23:simple\", (0, encoding_1.toAscii)(store));\n    return {\n      key: key,\n      value: value,\n      height: height,\n      // need to clone this: readonly input / writeable output\n      proof: {\n        ops: [...proof.ops]\n      }\n    };\n  }\n\n  async queryUnverified(path, request) {\n    const response = await this.tmClient.abciQuery({\n      path: path,\n      data: request,\n      prove: false\n    });\n\n    if (response.code) {\n      throw new Error(`Query failed with (${response.code}): ${response.log}`);\n    }\n\n    return response.value;\n  } // this must return the header for height+1\n  // throws an error if height is 0 or undefined\n\n\n  async getNextHeader(height) {\n    (0, utils_1.assertDefined)(height);\n\n    if (height === 0) {\n      throw new Error(\"Query returned height 0, cannot prove it\");\n    }\n\n    const searchHeight = height + 1;\n    let nextHeader;\n    let headersSubscription;\n\n    try {\n      headersSubscription = this.tmClient.subscribeNewBlockHeader();\n    } catch (_a) {// Ignore exception caused by non-WebSocket Tendermint clients\n    }\n\n    if (headersSubscription) {\n      const firstHeader = await (0, stream_1.firstEvent)(headersSubscription); // The first header we get might not be n+1 but n+2 or even higher. In such cases we fall back on a query.\n\n      if (firstHeader.height === searchHeight) {\n        nextHeader = firstHeader;\n      }\n    }\n\n    while (!nextHeader) {\n      // start from current height to avoid backend error for minHeight in the future\n      const correctHeader = (await this.tmClient.blockchain(height, searchHeight)).blockMetas.map(meta => meta.header).find(h => h.height === searchHeight);\n\n      if (correctHeader) {\n        nextHeader = correctHeader;\n      } else {\n        await (0, utils_1.sleep)(1000);\n      }\n    }\n\n    (0, utils_1.assert)(nextHeader.height === searchHeight, \"Got wrong header. This is a bug in the logic above.\");\n    return nextHeader;\n  }\n\n}\n\nexports.QueryClient = QueryClient;","map":{"version":3,"mappings":"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","names":["checkAndParseOp","op","kind","key","type","Error","ics23_1","CommitmentProof","decode","data","QueryClient","constructor","tmClient","withExtensions","client","extensionSetups","extensions","map","setupExtension","extension","moduleKey","moduleValue","Object","entries","current","queryVerified","store","desiredHeight","height","proof","value","queryRawProof","subProof","ops","storeProof","exist","length","nonexist","header","getNextHeader","appHash","queryKey","code","log","abciQuery","path","prove","_a","queryUnverified","request","response","searchHeight","nextHeader","headersSubscription","subscribeNewBlockHeader","firstHeader","correctHeader","blockchain","blockMetas","meta","find","h","exports"],"sourceRoot":"","sources":["../../src/queryclient/queryclient.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}