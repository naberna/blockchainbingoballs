{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Registry = exports.isTxBodyEncodeObject = exports.isPbjsGeneratedType = exports.isTsProtoGeneratedType = void 0;\n/* eslint-disable @typescript-eslint/naming-convention */\n\nconst tx_1 = require(\"cosmjs-types/cosmos/bank/v1beta1/tx\");\n\nconst coin_1 = require(\"cosmjs-types/cosmos/base/v1beta1/coin\");\n\nconst tx_2 = require(\"cosmjs-types/cosmos/tx/v1beta1/tx\");\n\nconst any_1 = require(\"cosmjs-types/google/protobuf/any\");\n\nfunction isTsProtoGeneratedType(type) {\n  return typeof type.fromPartial === \"function\";\n}\n\nexports.isTsProtoGeneratedType = isTsProtoGeneratedType;\n\nfunction isPbjsGeneratedType(type) {\n  return !isTsProtoGeneratedType(type);\n}\n\nexports.isPbjsGeneratedType = isPbjsGeneratedType;\nconst defaultTypeUrls = {\n  cosmosCoin: \"/cosmos.base.v1beta1.Coin\",\n  cosmosMsgSend: \"/cosmos.bank.v1beta1.MsgSend\",\n  cosmosTxBody: \"/cosmos.tx.v1beta1.TxBody\",\n  googleAny: \"/google.protobuf.Any\"\n};\n\nfunction isTxBodyEncodeObject(encodeObject) {\n  return encodeObject.typeUrl === \"/cosmos.tx.v1beta1.TxBody\";\n}\n\nexports.isTxBodyEncodeObject = isTxBodyEncodeObject;\n\nclass Registry {\n  /**\n   * Creates a new Registry for mapping protobuf type identifiers/type URLs to\n   * actual implementations. Those implementations are typically generated with ts-proto\n   * but we also support protobuf.js as a type generator.\n   *\n   * If there is no parameter given, a `new Registry()` adds the types `Coin` and `MsgSend`\n   * for historic reasons. Those can be overriden by customTypes.\n   *\n   * There are currently two methods for adding new types:\n   * 1. Passing types to the constructor.\n   * 2. Using the `register()` method\n   */\n  constructor(customTypes) {\n    const {\n      cosmosCoin,\n      cosmosMsgSend\n    } = defaultTypeUrls;\n    this.types = customTypes ? new Map([...customTypes]) : new Map([[cosmosCoin, coin_1.Coin], [cosmosMsgSend, tx_1.MsgSend]]);\n  }\n\n  register(typeUrl, type) {\n    this.types.set(typeUrl, type);\n  }\n  /**\n   * Looks up a type that was previously added to the registry.\n   *\n   * The generator information (ts-proto or pbjs) gets lost along the way.\n   * If you need to work with the result type in TypeScript, you can use:\n   *\n   * ```\n   * import { assert } from \"@cosmjs/utils\";\n   *\n   * const Coin = registry.lookupType(\"/cosmos.base.v1beta1.Coin\");\n   * assert(Coin); // Ensures not unset\n   * assert(isTsProtoGeneratedType(Coin)); // Ensures this is the type we expect\n   *\n   * // Coin is typed TsProtoGeneratedType now.\n   * ```\n   */\n\n\n  lookupType(typeUrl) {\n    return this.types.get(typeUrl);\n  }\n\n  lookupTypeWithError(typeUrl) {\n    const type = this.lookupType(typeUrl);\n\n    if (!type) {\n      throw new Error(`Unregistered type url: ${typeUrl}`);\n    }\n\n    return type;\n  }\n  /**\n   * Takes a typeUrl/value pair and encodes the value to protobuf if\n   * the given type was previously registered.\n   *\n   * If the value has to be wrapped in an Any, this needs to be done\n   * manually after this call. Or use `encodeAsAny` instead.\n   */\n\n\n  encode(encodeObject) {\n    const {\n      value,\n      typeUrl\n    } = encodeObject;\n\n    if (isTxBodyEncodeObject(encodeObject)) {\n      return this.encodeTxBody(value);\n    }\n\n    const type = this.lookupTypeWithError(typeUrl);\n    const instance = isTsProtoGeneratedType(type) ? type.fromPartial(value) : type.create(value);\n    return type.encode(instance).finish();\n  }\n  /**\n   * Takes a typeUrl/value pair and encodes the value to an Any if\n   * the given type was previously registered.\n   */\n\n\n  encodeAsAny(encodeObject) {\n    const binaryValue = this.encode(encodeObject);\n    return any_1.Any.fromPartial({\n      typeUrl: encodeObject.typeUrl,\n      value: binaryValue\n    });\n  }\n\n  encodeTxBody(txBodyFields) {\n    const wrappedMessages = txBodyFields.messages.map(message => this.encodeAsAny(message));\n    const txBody = tx_2.TxBody.fromPartial({ ...txBodyFields,\n      messages: wrappedMessages\n    });\n    return tx_2.TxBody.encode(txBody).finish();\n  }\n\n  decode(_ref) {\n    let {\n      typeUrl,\n      value\n    } = _ref;\n\n    if (typeUrl === defaultTypeUrls.cosmosTxBody) {\n      return this.decodeTxBody(value);\n    }\n\n    const type = this.lookupTypeWithError(typeUrl);\n    const decoded = type.decode(value);\n    Object.entries(decoded).forEach(_ref2 => {\n      let [key, val] = _ref2;\n\n      if (typeof Buffer !== \"undefined\" && typeof Buffer.isBuffer !== \"undefined\" && Buffer.isBuffer(val)) {\n        decoded[key] = Uint8Array.from(val);\n      }\n    });\n    return decoded;\n  }\n\n  decodeTxBody(txBody) {\n    const decodedTxBody = tx_2.TxBody.decode(txBody);\n    return { ...decodedTxBody,\n      messages: decodedTxBody.messages.map(_ref3 => {\n        let {\n          typeUrl: typeUrl,\n          value\n        } = _ref3;\n\n        if (!typeUrl) {\n          throw new Error(\"Missing type_url in Any\");\n        }\n\n        if (!value) {\n          throw new Error(\"Missing value in Any\");\n        }\n\n        return this.decode({\n          typeUrl,\n          value\n        });\n      })\n    };\n  }\n\n}\n\nexports.Registry = Registry;","map":{"version":3,"mappings":"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","names":["isTsProtoGeneratedType","type","fromPartial","exports","isPbjsGeneratedType","defaultTypeUrls","cosmosCoin","cosmosMsgSend","cosmosTxBody","googleAny","isTxBodyEncodeObject","encodeObject","typeUrl","Registry","constructor","customTypes","types","Map","coin_1","tx_1","register","set","lookupType","get","lookupTypeWithError","Error","encode","value","encodeTxBody","instance","create","finish","encodeAsAny","binaryValue","any_1","txBodyFields","wrappedMessages","messages","map","message","txBody","tx_2","decode","decodeTxBody","decoded","Object","entries","forEach","key","val","Buffer","isBuffer","Uint8Array","from","decodedTxBody"],"sourceRoot":"","sources":["../src/registry.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}