{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Secp256k1 = void 0;\n\nconst encoding_1 = require(\"@cosmjs/encoding\");\n\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\n\nconst elliptic_1 = __importDefault(require(\"elliptic\"));\n\nconst secp256k1signature_1 = require(\"./secp256k1signature\");\n\nconst secp256k1 = new elliptic_1.default.ec(\"secp256k1\");\nconst secp256k1N = new bn_js_1.default(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\", \"hex\");\n\nclass Secp256k1 {\n  /**\n   * Takes a 32 byte private key and returns a privkey/pubkey pair.\n   *\n   * The resulting pubkey is uncompressed. For the use in Cosmos it should\n   * be compressed first using `Secp256k1.compressPubkey`.\n   */\n  static async makeKeypair(privkey) {\n    if (privkey.length !== 32) {\n      // is this check missing in secp256k1.validatePrivateKey?\n      // https://github.com/bitjson/bitcoin-ts/issues/4\n      throw new Error(\"input data is not a valid secp256k1 private key\");\n    }\n\n    const keypair = secp256k1.keyFromPrivate(privkey);\n\n    if (keypair.validate().result !== true) {\n      throw new Error(\"input data is not a valid secp256k1 private key\");\n    } // range test that is not part of the elliptic implementation\n\n\n    const privkeyAsBigInteger = new bn_js_1.default(privkey);\n\n    if (privkeyAsBigInteger.gte(secp256k1N)) {\n      // not strictly smaller than N\n      throw new Error(\"input data is not a valid secp256k1 private key\");\n    }\n\n    const out = {\n      privkey: (0, encoding_1.fromHex)(keypair.getPrivate(\"hex\")),\n      // encodes uncompressed as\n      // - 1-byte prefix \"04\"\n      // - 32-byte x coordinate\n      // - 32-byte y coordinate\n      pubkey: Uint8Array.from(keypair.getPublic(\"array\"))\n    };\n    return out;\n  }\n  /**\n   * Creates a signature that is\n   * - deterministic (RFC 6979)\n   * - lowS signature\n   * - DER encoded\n   */\n\n\n  static async createSignature(messageHash, privkey) {\n    if (messageHash.length === 0) {\n      throw new Error(\"Message hash must not be empty\");\n    }\n\n    if (messageHash.length > 32) {\n      throw new Error(\"Message hash length must not exceed 32 bytes\");\n    }\n\n    const keypair = secp256k1.keyFromPrivate(privkey); // the `canonical` option ensures creation of lowS signature representations\n\n    const {\n      r,\n      s,\n      recoveryParam\n    } = keypair.sign(messageHash, {\n      canonical: true\n    });\n    if (typeof recoveryParam !== \"number\") throw new Error(\"Recovery param missing\");\n    return new secp256k1signature_1.ExtendedSecp256k1Signature(Uint8Array.from(r.toArray()), Uint8Array.from(s.toArray()), recoveryParam);\n  }\n\n  static async verifySignature(signature, messageHash, pubkey) {\n    if (messageHash.length === 0) {\n      throw new Error(\"Message hash must not be empty\");\n    }\n\n    if (messageHash.length > 32) {\n      throw new Error(\"Message hash length must not exceed 32 bytes\");\n    }\n\n    const keypair = secp256k1.keyFromPublic(pubkey); // From https://github.com/indutny/elliptic:\n    //\n    //     Sign the message's hash (input must be an array, or a hex-string)\n    //\n    //     Signature MUST be either:\n    //     1) DER-encoded signature as hex-string; or\n    //     2) DER-encoded signature as buffer; or\n    //     3) object with two hex-string properties (r and s); or\n    //     4) object with two buffer properties (r and s)\n    //\n    // Uint8Array is not a Buffer, but elliptic seems to be happy with the interface\n    // common to both types. Uint8Array is not an array of ints but the interface is\n    // similar\n\n    try {\n      return keypair.verify(messageHash, signature.toDer());\n    } catch (error) {\n      return false;\n    }\n  }\n\n  static recoverPubkey(signature, messageHash) {\n    const signatureForElliptic = {\n      r: (0, encoding_1.toHex)(signature.r()),\n      s: (0, encoding_1.toHex)(signature.s())\n    };\n    const point = secp256k1.recoverPubKey(messageHash, signatureForElliptic, signature.recovery);\n    const keypair = secp256k1.keyFromPublic(point);\n    return (0, encoding_1.fromHex)(keypair.getPublic(false, \"hex\"));\n  }\n  /**\n   * Takes a compressed or uncompressed pubkey and return a compressed one.\n   *\n   * This function is idempotent.\n   */\n\n\n  static compressPubkey(pubkey) {\n    switch (pubkey.length) {\n      case 33:\n        return pubkey;\n\n      case 65:\n        return Uint8Array.from(secp256k1.keyFromPublic(pubkey).getPublic(true, \"array\"));\n\n      default:\n        throw new Error(\"Invalid pubkey length\");\n    }\n  }\n  /**\n   * Takes a compressed or uncompressed pubkey and returns an uncompressed one.\n   *\n   * This function is idempotent.\n   */\n\n\n  static uncompressPubkey(pubkey) {\n    switch (pubkey.length) {\n      case 33:\n        return Uint8Array.from(secp256k1.keyFromPublic(pubkey).getPublic(false, \"array\"));\n\n      case 65:\n        return pubkey;\n\n      default:\n        throw new Error(\"Invalid pubkey length\");\n    }\n  }\n\n  static trimRecoveryByte(signature) {\n    switch (signature.length) {\n      case 64:\n        return signature;\n\n      case 65:\n        return signature.slice(0, 64);\n\n      default:\n        throw new Error(\"Invalid signature length\");\n    }\n  }\n\n}\n\nexports.Secp256k1 = Secp256k1;","map":{"version":3,"mappings":"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","names":["secp256k1","elliptic_1","ec","secp256k1N","bn_js_1","Secp256k1","makeKeypair","privkey","length","Error","keypair","keyFromPrivate","validate","result","privkeyAsBigInteger","gte","out","getPrivate","pubkey","Uint8Array","from","getPublic","createSignature","messageHash","r","s","recoveryParam","sign","canonical","secp256k1signature_1","toArray","verifySignature","signature","keyFromPublic","verify","toDer","error","recoverPubkey","signatureForElliptic","point","recoverPubKey","recovery","compressPubkey","uncompressPubkey","trimRecoveryByte","slice","exports"],"sourceRoot":"","sources":["../src/secp256k1.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}