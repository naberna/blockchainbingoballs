{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ensureLeftNeighbor = exports.ensureSpec = exports.calculateExistenceRoot = exports.verifyNonExistence = exports.verifyExistence = exports.smtSpec = exports.tendermintSpec = exports.iavlSpec = void 0;\n\nconst codecimpl_1 = require(\"./generated/codecimpl\");\n\nconst ops_1 = require(\"./ops\");\n\nconst specs_1 = require(\"./specs\");\n\nexports.iavlSpec = {\n  leafSpec: {\n    prefix: Uint8Array.from([0]),\n    hash: codecimpl_1.ics23.HashOp.SHA256,\n    prehashValue: codecimpl_1.ics23.HashOp.SHA256,\n    prehashKey: codecimpl_1.ics23.HashOp.NO_HASH,\n    length: codecimpl_1.ics23.LengthOp.VAR_PROTO\n  },\n  innerSpec: {\n    childOrder: [0, 1],\n    minPrefixLength: 4,\n    maxPrefixLength: 12,\n    childSize: 33,\n    hash: codecimpl_1.ics23.HashOp.SHA256\n  }\n};\nexports.tendermintSpec = {\n  leafSpec: {\n    prefix: Uint8Array.from([0]),\n    hash: codecimpl_1.ics23.HashOp.SHA256,\n    prehashValue: codecimpl_1.ics23.HashOp.SHA256,\n    prehashKey: codecimpl_1.ics23.HashOp.NO_HASH,\n    length: codecimpl_1.ics23.LengthOp.VAR_PROTO\n  },\n  innerSpec: {\n    childOrder: [0, 1],\n    minPrefixLength: 1,\n    maxPrefixLength: 1,\n    childSize: 32,\n    hash: codecimpl_1.ics23.HashOp.SHA256\n  }\n};\nexports.smtSpec = {\n  leafSpec: {\n    hash: codecimpl_1.ics23.HashOp.SHA256,\n    prehashKey: codecimpl_1.ics23.HashOp.NO_HASH,\n    prehashValue: codecimpl_1.ics23.HashOp.SHA256,\n    length: codecimpl_1.ics23.LengthOp.NO_PREFIX,\n    prefix: Uint8Array.from([0])\n  },\n  innerSpec: {\n    childOrder: [0, 1],\n    childSize: 32,\n    minPrefixLength: 1,\n    maxPrefixLength: 1,\n    emptyChild: new Uint8Array(32),\n    hash: codecimpl_1.ics23.HashOp.SHA256\n  },\n  maxDepth: 256\n}; // verifyExistence will throw an error if the proof doesn't link key, value -> root\n// or if it doesn't fulfill the spec\n\nfunction verifyExistence(proof, spec, root, key, value) {\n  ensureSpec(proof, spec);\n  const calc = calculateExistenceRoot(proof);\n  (0, specs_1.ensureBytesEqual)(calc, root);\n  (0, specs_1.ensureBytesEqual)(key, proof.key);\n  (0, specs_1.ensureBytesEqual)(value, proof.value);\n}\n\nexports.verifyExistence = verifyExistence; // Verify does all checks to ensure the proof has valid non-existence proofs,\n// and they ensure the given key is not in the CommitmentState,\n// throwing an error if there is an issue\n\nfunction verifyNonExistence(proof, spec, root, key) {\n  let leftKey;\n  let rightKey;\n\n  if (proof.left) {\n    verifyExistence(proof.left, spec, root, proof.left.key, proof.left.value);\n    leftKey = proof.left.key;\n  }\n\n  if (proof.right) {\n    verifyExistence(proof.right, spec, root, proof.right.key, proof.right.value);\n    rightKey = proof.right.key;\n  }\n\n  if (!leftKey && !rightKey) {\n    throw new Error(\"neither left nor right proof defined\");\n  }\n\n  if (leftKey) {\n    (0, specs_1.ensureBytesBefore)(leftKey, key);\n  }\n\n  if (rightKey) {\n    (0, specs_1.ensureBytesBefore)(key, rightKey);\n  }\n\n  if (!spec.innerSpec) {\n    throw new Error(\"no inner spec\");\n  }\n\n  if (!leftKey) {\n    ensureLeftMost(spec.innerSpec, proof.right.path);\n  } else if (!rightKey) {\n    ensureRightMost(spec.innerSpec, proof.left.path);\n  } else {\n    ensureLeftNeighbor(spec.innerSpec, proof.left.path, proof.right.path);\n  }\n\n  return;\n}\n\nexports.verifyNonExistence = verifyNonExistence; // Calculate determines the root hash that matches the given proof.\n// You must validate the result is what you have in a header.\n// Returns error if the calculations cannot be performed.\n\nfunction calculateExistenceRoot(proof) {\n  if (!proof.key || !proof.value) {\n    throw new Error(\"Existence proof needs key and value set\");\n  }\n\n  if (!proof.leaf) {\n    throw new Error(\"Existence proof must start with a leaf operation\");\n  }\n\n  const path = proof.path || [];\n  let res = (0, ops_1.applyLeaf)(proof.leaf, proof.key, proof.value);\n\n  for (const inner of path) {\n    res = (0, ops_1.applyInner)(inner, res);\n  }\n\n  return res;\n}\n\nexports.calculateExistenceRoot = calculateExistenceRoot; // ensureSpec throws an Error if proof doesn't fulfill spec\n\nfunction ensureSpec(proof, spec) {\n  if (!proof.leaf) {\n    throw new Error(\"Existence proof must start with a leaf operation\");\n  }\n\n  if (!spec.leafSpec) {\n    throw new Error(\"Spec must include leafSpec\");\n  }\n\n  if (!spec.innerSpec) {\n    throw new Error(\"Spec must include innerSpec\");\n  }\n\n  (0, specs_1.ensureLeaf)(proof.leaf, spec.leafSpec);\n  const path = proof.path || [];\n\n  if (spec.minDepth && path.length < spec.minDepth) {\n    throw new Error(`Too few inner nodes ${path.length}`);\n  }\n\n  if (spec.maxDepth && path.length > spec.maxDepth) {\n    throw new Error(`Too many inner nodes ${path.length}`);\n  }\n\n  for (const inner of path) {\n    (0, specs_1.ensureInner)(inner, spec.leafSpec.prefix, spec.innerSpec);\n  }\n}\n\nexports.ensureSpec = ensureSpec;\n\nfunction ensureLeftMost(spec, path) {\n  const {\n    minPrefix,\n    maxPrefix,\n    suffix\n  } = getPadding(spec, 0); // ensure every step has a prefix and suffix defined to be leftmost\n\n  for (const step of path) {\n    if (!hasPadding(step, minPrefix, maxPrefix, suffix)) {\n      throw new Error(\"Step not leftmost\");\n    }\n  }\n}\n\nfunction ensureRightMost(spec, path) {\n  const len = spec.childOrder.length - 1;\n  const {\n    minPrefix,\n    maxPrefix,\n    suffix\n  } = getPadding(spec, len); // ensure every step has a prefix and suffix defined to be leftmost\n\n  for (const step of path) {\n    if (!hasPadding(step, minPrefix, maxPrefix, suffix)) {\n      throw new Error(\"Step not leftmost\");\n    }\n  }\n}\n\nfunction ensureLeftNeighbor(spec, left, right) {\n  const mutleft = [...left];\n  const mutright = [...right];\n  let topleft = mutleft.pop();\n  let topright = mutright.pop();\n\n  while ((0, specs_1.bytesEqual)(topleft.prefix, topright.prefix) && (0, specs_1.bytesEqual)(topleft.suffix, topright.suffix)) {\n    topleft = mutleft.pop();\n    topright = mutright.pop();\n  } // now topleft and topright are the first divergent nodes\n  // make sure they are left and right of each other\n\n\n  if (!isLeftStep(spec, topleft, topright)) {\n    throw new Error(`Not left neightbor at first divergent step`);\n  } // make sure the paths are left and right most possibilities respectively\n\n\n  ensureRightMost(spec, mutleft);\n  ensureLeftMost(spec, mutright);\n}\n\nexports.ensureLeftNeighbor = ensureLeftNeighbor; // isLeftStep assumes left and right have common parents\n// checks if left is exactly one slot to the left of right\n\nfunction isLeftStep(spec, left, right) {\n  const leftidx = orderFromPadding(spec, left);\n  const rightidx = orderFromPadding(spec, right);\n  return rightidx === leftidx + 1;\n}\n\nfunction orderFromPadding(spec, inner) {\n  for (let branch = 0; branch < spec.childOrder.length; branch++) {\n    const {\n      minPrefix,\n      maxPrefix,\n      suffix\n    } = getPadding(spec, branch);\n\n    if (hasPadding(inner, minPrefix, maxPrefix, suffix)) {\n      return branch;\n    }\n  }\n\n  throw new Error(`Cannot find any valid spacing for this node`);\n}\n\nfunction hasPadding(op, minPrefix, maxPrefix, suffix) {\n  if ((op.prefix || []).length < minPrefix) {\n    return false;\n  }\n\n  if ((op.prefix || []).length > maxPrefix) {\n    return false;\n  }\n\n  return (op.suffix || []).length === suffix;\n}\n\nfunction getPadding(spec, branch) {\n  const idx = getPosition(spec.childOrder, branch); // count how many children are in the prefix\n\n  const prefix = idx * spec.childSize;\n  const minPrefix = prefix + spec.minPrefixLength;\n  const maxPrefix = prefix + spec.maxPrefixLength; // count how many children are in the suffix\n\n  const suffix = (spec.childOrder.length - 1 - idx) * spec.childSize;\n  return {\n    minPrefix,\n    maxPrefix,\n    suffix\n  };\n}\n\nfunction getPosition(order, branch) {\n  if (branch < 0 || branch >= order.length) {\n    throw new Error(`Invalid branch: ${branch}`);\n  }\n\n  return order.findIndex(val => val === branch);\n}","map":{"version":3,"mappings":"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","names":["exports","leafSpec","prefix","Uint8Array","from","hash","codecimpl_1","HashOp","SHA256","prehashValue","prehashKey","NO_HASH","length","LengthOp","VAR_PROTO","innerSpec","childOrder","minPrefixLength","maxPrefixLength","childSize","NO_PREFIX","emptyChild","maxDepth","verifyExistence","proof","spec","root","key","value","ensureSpec","calc","calculateExistenceRoot","verifyNonExistence","leftKey","rightKey","left","right","Error","ensureLeftMost","path","ensureRightMost","ensureLeftNeighbor","leaf","res","inner","minDepth","minPrefix","maxPrefix","suffix","getPadding","step","hasPadding","len","mutleft","mutright","topleft","pop","topright","isLeftStep","leftidx","orderFromPadding","rightidx","branch","op","idx","getPosition","order","findIndex","val"],"sourceRoot":"","sources":["../src/proofs.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}