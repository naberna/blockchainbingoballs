{"ast":null,"code":"/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n\"use strict\";\n\nvar $protobuf = require(\"protobufjs/minimal\"); // Common aliases\n\n\nvar $Reader = $protobuf.Reader,\n    $Writer = $protobuf.Writer,\n    $util = $protobuf.util; // Exported root namespace\n\nvar $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n\n$root.ics23 = function () {\n  /**\n   * Namespace ics23.\n   * @exports ics23\n   * @namespace\n   */\n  var ics23 = {};\n  /**\n   * HashOp enum.\n   * @name ics23.HashOp\n   * @enum {string}\n   * @property {number} NO_HASH=0 NO_HASH value\n   * @property {number} SHA256=1 SHA256 value\n   * @property {number} SHA512=2 SHA512 value\n   * @property {number} KECCAK=3 KECCAK value\n   * @property {number} RIPEMD160=4 RIPEMD160 value\n   * @property {number} BITCOIN=5 BITCOIN value\n   * @property {number} SHA512_256=6 SHA512_256 value\n   */\n\n  ics23.HashOp = function () {\n    var valuesById = {},\n        values = Object.create(valuesById);\n    values[valuesById[0] = \"NO_HASH\"] = 0;\n    values[valuesById[1] = \"SHA256\"] = 1;\n    values[valuesById[2] = \"SHA512\"] = 2;\n    values[valuesById[3] = \"KECCAK\"] = 3;\n    values[valuesById[4] = \"RIPEMD160\"] = 4;\n    values[valuesById[5] = \"BITCOIN\"] = 5;\n    values[valuesById[6] = \"SHA512_256\"] = 6;\n    return values;\n  }();\n  /**\n   * LengthOp defines how to process the key and value of the LeafOp\n   * to include length information. After encoding the length with the given\n   * algorithm, the length will be prepended to the key and value bytes.\n   * (Each one with it's own encoded length)\n   * @name ics23.LengthOp\n   * @enum {string}\n   * @property {number} NO_PREFIX=0 NO_PREFIX value\n   * @property {number} VAR_PROTO=1 VAR_PROTO value\n   * @property {number} VAR_RLP=2 VAR_RLP value\n   * @property {number} FIXED32_BIG=3 FIXED32_BIG value\n   * @property {number} FIXED32_LITTLE=4 FIXED32_LITTLE value\n   * @property {number} FIXED64_BIG=5 FIXED64_BIG value\n   * @property {number} FIXED64_LITTLE=6 FIXED64_LITTLE value\n   * @property {number} REQUIRE_32_BYTES=7 REQUIRE_32_BYTES value\n   * @property {number} REQUIRE_64_BYTES=8 REQUIRE_64_BYTES value\n   */\n\n\n  ics23.LengthOp = function () {\n    var valuesById = {},\n        values = Object.create(valuesById);\n    values[valuesById[0] = \"NO_PREFIX\"] = 0;\n    values[valuesById[1] = \"VAR_PROTO\"] = 1;\n    values[valuesById[2] = \"VAR_RLP\"] = 2;\n    values[valuesById[3] = \"FIXED32_BIG\"] = 3;\n    values[valuesById[4] = \"FIXED32_LITTLE\"] = 4;\n    values[valuesById[5] = \"FIXED64_BIG\"] = 5;\n    values[valuesById[6] = \"FIXED64_LITTLE\"] = 6;\n    values[valuesById[7] = \"REQUIRE_32_BYTES\"] = 7;\n    values[valuesById[8] = \"REQUIRE_64_BYTES\"] = 8;\n    return values;\n  }();\n\n  ics23.ExistenceProof = function () {\n    /**\n     * Properties of an ExistenceProof.\n     * @memberof ics23\n     * @interface IExistenceProof\n     * @property {Uint8Array|null} [key] ExistenceProof key\n     * @property {Uint8Array|null} [value] ExistenceProof value\n     * @property {ics23.ILeafOp|null} [leaf] ExistenceProof leaf\n     * @property {Array.<ics23.IInnerOp>|null} [path] ExistenceProof path\n     */\n\n    /**\n     * Constructs a new ExistenceProof.\n     * @memberof ics23\n     * @classdesc ExistenceProof takes a key and a value and a set of steps to perform on it.\n     * The result of peforming all these steps will provide a \"root hash\", which can\n     * be compared to the value in a header.\n     * \n     * Since it is computationally infeasible to produce a hash collission for any of the used\n     * cryptographic hash functions, if someone can provide a series of operations to transform\n     * a given key and value into a root hash that matches some trusted root, these key and values\n     * must be in the referenced merkle tree.\n     * \n     * The only possible issue is maliablity in LeafOp, such as providing extra prefix data,\n     * which should be controlled by a spec. Eg. with lengthOp as NONE,\n     * prefix = FOO, key = BAR, value = CHOICE\n     * and\n     * prefix = F, key = OOBAR, value = CHOICE\n     * would produce the same value.\n     * \n     * With LengthOp this is tricker but not impossible. Which is why the \"leafPrefixEqual\" field\n     * in the ProofSpec is valuable to prevent this mutability. And why all trees should\n     * length-prefix the data before hashing it.\n     * @implements IExistenceProof\n     * @constructor\n     * @param {ics23.IExistenceProof=} [properties] Properties to set\n     */\n    function ExistenceProof(properties) {\n      this.path = [];\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * ExistenceProof key.\n     * @member {Uint8Array} key\n     * @memberof ics23.ExistenceProof\n     * @instance\n     */\n\n\n    ExistenceProof.prototype.key = $util.newBuffer([]);\n    /**\n     * ExistenceProof value.\n     * @member {Uint8Array} value\n     * @memberof ics23.ExistenceProof\n     * @instance\n     */\n\n    ExistenceProof.prototype.value = $util.newBuffer([]);\n    /**\n     * ExistenceProof leaf.\n     * @member {ics23.ILeafOp|null|undefined} leaf\n     * @memberof ics23.ExistenceProof\n     * @instance\n     */\n\n    ExistenceProof.prototype.leaf = null;\n    /**\n     * ExistenceProof path.\n     * @member {Array.<ics23.IInnerOp>} path\n     * @memberof ics23.ExistenceProof\n     * @instance\n     */\n\n    ExistenceProof.prototype.path = $util.emptyArray;\n    /**\n     * Creates a new ExistenceProof instance using the specified properties.\n     * @function create\n     * @memberof ics23.ExistenceProof\n     * @static\n     * @param {ics23.IExistenceProof=} [properties] Properties to set\n     * @returns {ics23.ExistenceProof} ExistenceProof instance\n     */\n\n    ExistenceProof.create = function create(properties) {\n      return new ExistenceProof(properties);\n    };\n    /**\n     * Encodes the specified ExistenceProof message. Does not implicitly {@link ics23.ExistenceProof.verify|verify} messages.\n     * @function encode\n     * @memberof ics23.ExistenceProof\n     * @static\n     * @param {ics23.IExistenceProof} message ExistenceProof message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    ExistenceProof.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.key != null && message.hasOwnProperty(\"key\")) writer.uint32(\n      /* id 1, wireType 2 =*/\n      10).bytes(message.key);\n      if (message.value != null && message.hasOwnProperty(\"value\")) writer.uint32(\n      /* id 2, wireType 2 =*/\n      18).bytes(message.value);\n      if (message.leaf != null && message.hasOwnProperty(\"leaf\")) $root.ics23.LeafOp.encode(message.leaf, writer.uint32(\n      /* id 3, wireType 2 =*/\n      26).fork()).ldelim();\n      if (message.path != null && message.path.length) for (var i = 0; i < message.path.length; ++i) $root.ics23.InnerOp.encode(message.path[i], writer.uint32(\n      /* id 4, wireType 2 =*/\n      34).fork()).ldelim();\n      return writer;\n    };\n    /**\n     * Encodes the specified ExistenceProof message, length delimited. Does not implicitly {@link ics23.ExistenceProof.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ics23.ExistenceProof\n     * @static\n     * @param {ics23.IExistenceProof} message ExistenceProof message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    ExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes an ExistenceProof message from the specified reader or buffer.\n     * @function decode\n     * @memberof ics23.ExistenceProof\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ics23.ExistenceProof} ExistenceProof\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    ExistenceProof.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.ics23.ExistenceProof();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.key = reader.bytes();\n            break;\n\n          case 2:\n            message.value = reader.bytes();\n            break;\n\n          case 3:\n            message.leaf = $root.ics23.LeafOp.decode(reader, reader.uint32());\n            break;\n\n          case 4:\n            if (!(message.path && message.path.length)) message.path = [];\n            message.path.push($root.ics23.InnerOp.decode(reader, reader.uint32()));\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes an ExistenceProof message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ics23.ExistenceProof\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ics23.ExistenceProof} ExistenceProof\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    ExistenceProof.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies an ExistenceProof message.\n     * @function verify\n     * @memberof ics23.ExistenceProof\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    ExistenceProof.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n      if (message.key != null && message.hasOwnProperty(\"key\")) if (!(message.key && typeof message.key.length === \"number\" || $util.isString(message.key))) return \"key: buffer expected\";\n      if (message.value != null && message.hasOwnProperty(\"value\")) if (!(message.value && typeof message.value.length === \"number\" || $util.isString(message.value))) return \"value: buffer expected\";\n\n      if (message.leaf != null && message.hasOwnProperty(\"leaf\")) {\n        var error = $root.ics23.LeafOp.verify(message.leaf);\n        if (error) return \"leaf.\" + error;\n      }\n\n      if (message.path != null && message.hasOwnProperty(\"path\")) {\n        if (!Array.isArray(message.path)) return \"path: array expected\";\n\n        for (var i = 0; i < message.path.length; ++i) {\n          var error = $root.ics23.InnerOp.verify(message.path[i]);\n          if (error) return \"path.\" + error;\n        }\n      }\n\n      return null;\n    };\n    /**\n     * Creates an ExistenceProof message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof ics23.ExistenceProof\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {ics23.ExistenceProof} ExistenceProof\n     */\n\n\n    ExistenceProof.fromObject = function fromObject(object) {\n      if (object instanceof $root.ics23.ExistenceProof) return object;\n      var message = new $root.ics23.ExistenceProof();\n      if (object.key != null) if (typeof object.key === \"string\") $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);else if (object.key.length) message.key = object.key;\n      if (object.value != null) if (typeof object.value === \"string\") $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);else if (object.value.length) message.value = object.value;\n\n      if (object.leaf != null) {\n        if (typeof object.leaf !== \"object\") throw TypeError(\".ics23.ExistenceProof.leaf: object expected\");\n        message.leaf = $root.ics23.LeafOp.fromObject(object.leaf);\n      }\n\n      if (object.path) {\n        if (!Array.isArray(object.path)) throw TypeError(\".ics23.ExistenceProof.path: array expected\");\n        message.path = [];\n\n        for (var i = 0; i < object.path.length; ++i) {\n          if (typeof object.path[i] !== \"object\") throw TypeError(\".ics23.ExistenceProof.path: object expected\");\n          message.path[i] = $root.ics23.InnerOp.fromObject(object.path[i]);\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Creates a plain object from an ExistenceProof message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ics23.ExistenceProof\n     * @static\n     * @param {ics23.ExistenceProof} message ExistenceProof\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    ExistenceProof.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.arrays || options.defaults) object.path = [];\n\n      if (options.defaults) {\n        if (options.bytes === String) object.key = \"\";else {\n          object.key = [];\n          if (options.bytes !== Array) object.key = $util.newBuffer(object.key);\n        }\n        if (options.bytes === String) object.value = \"\";else {\n          object.value = [];\n          if (options.bytes !== Array) object.value = $util.newBuffer(object.value);\n        }\n        object.leaf = null;\n      }\n\n      if (message.key != null && message.hasOwnProperty(\"key\")) object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;\n      if (message.value != null && message.hasOwnProperty(\"value\")) object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;\n      if (message.leaf != null && message.hasOwnProperty(\"leaf\")) object.leaf = $root.ics23.LeafOp.toObject(message.leaf, options);\n\n      if (message.path && message.path.length) {\n        object.path = [];\n\n        for (var j = 0; j < message.path.length; ++j) object.path[j] = $root.ics23.InnerOp.toObject(message.path[j], options);\n      }\n\n      return object;\n    };\n    /**\n     * Converts this ExistenceProof to JSON.\n     * @function toJSON\n     * @memberof ics23.ExistenceProof\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    ExistenceProof.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return ExistenceProof;\n  }();\n\n  ics23.NonExistenceProof = function () {\n    /**\n     * Properties of a NonExistenceProof.\n     * @memberof ics23\n     * @interface INonExistenceProof\n     * @property {Uint8Array|null} [key] NonExistenceProof key\n     * @property {ics23.IExistenceProof|null} [left] NonExistenceProof left\n     * @property {ics23.IExistenceProof|null} [right] NonExistenceProof right\n     */\n\n    /**\n     * Constructs a new NonExistenceProof.\n     * @memberof ics23\n     * @classdesc Represents a NonExistenceProof.\n     * @implements INonExistenceProof\n     * @constructor\n     * @param {ics23.INonExistenceProof=} [properties] Properties to set\n     */\n    function NonExistenceProof(properties) {\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * NonExistenceProof key.\n     * @member {Uint8Array} key\n     * @memberof ics23.NonExistenceProof\n     * @instance\n     */\n\n\n    NonExistenceProof.prototype.key = $util.newBuffer([]);\n    /**\n     * NonExistenceProof left.\n     * @member {ics23.IExistenceProof|null|undefined} left\n     * @memberof ics23.NonExistenceProof\n     * @instance\n     */\n\n    NonExistenceProof.prototype.left = null;\n    /**\n     * NonExistenceProof right.\n     * @member {ics23.IExistenceProof|null|undefined} right\n     * @memberof ics23.NonExistenceProof\n     * @instance\n     */\n\n    NonExistenceProof.prototype.right = null;\n    /**\n     * Creates a new NonExistenceProof instance using the specified properties.\n     * @function create\n     * @memberof ics23.NonExistenceProof\n     * @static\n     * @param {ics23.INonExistenceProof=} [properties] Properties to set\n     * @returns {ics23.NonExistenceProof} NonExistenceProof instance\n     */\n\n    NonExistenceProof.create = function create(properties) {\n      return new NonExistenceProof(properties);\n    };\n    /**\n     * Encodes the specified NonExistenceProof message. Does not implicitly {@link ics23.NonExistenceProof.verify|verify} messages.\n     * @function encode\n     * @memberof ics23.NonExistenceProof\n     * @static\n     * @param {ics23.INonExistenceProof} message NonExistenceProof message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    NonExistenceProof.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.key != null && message.hasOwnProperty(\"key\")) writer.uint32(\n      /* id 1, wireType 2 =*/\n      10).bytes(message.key);\n      if (message.left != null && message.hasOwnProperty(\"left\")) $root.ics23.ExistenceProof.encode(message.left, writer.uint32(\n      /* id 2, wireType 2 =*/\n      18).fork()).ldelim();\n      if (message.right != null && message.hasOwnProperty(\"right\")) $root.ics23.ExistenceProof.encode(message.right, writer.uint32(\n      /* id 3, wireType 2 =*/\n      26).fork()).ldelim();\n      return writer;\n    };\n    /**\n     * Encodes the specified NonExistenceProof message, length delimited. Does not implicitly {@link ics23.NonExistenceProof.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ics23.NonExistenceProof\n     * @static\n     * @param {ics23.INonExistenceProof} message NonExistenceProof message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    NonExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes a NonExistenceProof message from the specified reader or buffer.\n     * @function decode\n     * @memberof ics23.NonExistenceProof\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ics23.NonExistenceProof} NonExistenceProof\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    NonExistenceProof.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.ics23.NonExistenceProof();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.key = reader.bytes();\n            break;\n\n          case 2:\n            message.left = $root.ics23.ExistenceProof.decode(reader, reader.uint32());\n            break;\n\n          case 3:\n            message.right = $root.ics23.ExistenceProof.decode(reader, reader.uint32());\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes a NonExistenceProof message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ics23.NonExistenceProof\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ics23.NonExistenceProof} NonExistenceProof\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    NonExistenceProof.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies a NonExistenceProof message.\n     * @function verify\n     * @memberof ics23.NonExistenceProof\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    NonExistenceProof.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n      if (message.key != null && message.hasOwnProperty(\"key\")) if (!(message.key && typeof message.key.length === \"number\" || $util.isString(message.key))) return \"key: buffer expected\";\n\n      if (message.left != null && message.hasOwnProperty(\"left\")) {\n        var error = $root.ics23.ExistenceProof.verify(message.left);\n        if (error) return \"left.\" + error;\n      }\n\n      if (message.right != null && message.hasOwnProperty(\"right\")) {\n        var error = $root.ics23.ExistenceProof.verify(message.right);\n        if (error) return \"right.\" + error;\n      }\n\n      return null;\n    };\n    /**\n     * Creates a NonExistenceProof message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof ics23.NonExistenceProof\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {ics23.NonExistenceProof} NonExistenceProof\n     */\n\n\n    NonExistenceProof.fromObject = function fromObject(object) {\n      if (object instanceof $root.ics23.NonExistenceProof) return object;\n      var message = new $root.ics23.NonExistenceProof();\n      if (object.key != null) if (typeof object.key === \"string\") $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);else if (object.key.length) message.key = object.key;\n\n      if (object.left != null) {\n        if (typeof object.left !== \"object\") throw TypeError(\".ics23.NonExistenceProof.left: object expected\");\n        message.left = $root.ics23.ExistenceProof.fromObject(object.left);\n      }\n\n      if (object.right != null) {\n        if (typeof object.right !== \"object\") throw TypeError(\".ics23.NonExistenceProof.right: object expected\");\n        message.right = $root.ics23.ExistenceProof.fromObject(object.right);\n      }\n\n      return message;\n    };\n    /**\n     * Creates a plain object from a NonExistenceProof message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ics23.NonExistenceProof\n     * @static\n     * @param {ics23.NonExistenceProof} message NonExistenceProof\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    NonExistenceProof.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n\n      if (options.defaults) {\n        if (options.bytes === String) object.key = \"\";else {\n          object.key = [];\n          if (options.bytes !== Array) object.key = $util.newBuffer(object.key);\n        }\n        object.left = null;\n        object.right = null;\n      }\n\n      if (message.key != null && message.hasOwnProperty(\"key\")) object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;\n      if (message.left != null && message.hasOwnProperty(\"left\")) object.left = $root.ics23.ExistenceProof.toObject(message.left, options);\n      if (message.right != null && message.hasOwnProperty(\"right\")) object.right = $root.ics23.ExistenceProof.toObject(message.right, options);\n      return object;\n    };\n    /**\n     * Converts this NonExistenceProof to JSON.\n     * @function toJSON\n     * @memberof ics23.NonExistenceProof\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    NonExistenceProof.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return NonExistenceProof;\n  }();\n\n  ics23.CommitmentProof = function () {\n    /**\n     * Properties of a CommitmentProof.\n     * @memberof ics23\n     * @interface ICommitmentProof\n     * @property {ics23.IExistenceProof|null} [exist] CommitmentProof exist\n     * @property {ics23.INonExistenceProof|null} [nonexist] CommitmentProof nonexist\n     * @property {ics23.IBatchProof|null} [batch] CommitmentProof batch\n     * @property {ics23.ICompressedBatchProof|null} [compressed] CommitmentProof compressed\n     */\n\n    /**\n     * Constructs a new CommitmentProof.\n     * @memberof ics23\n     * @classdesc Represents a CommitmentProof.\n     * @implements ICommitmentProof\n     * @constructor\n     * @param {ics23.ICommitmentProof=} [properties] Properties to set\n     */\n    function CommitmentProof(properties) {\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CommitmentProof exist.\n     * @member {ics23.IExistenceProof|null|undefined} exist\n     * @memberof ics23.CommitmentProof\n     * @instance\n     */\n\n\n    CommitmentProof.prototype.exist = null;\n    /**\n     * CommitmentProof nonexist.\n     * @member {ics23.INonExistenceProof|null|undefined} nonexist\n     * @memberof ics23.CommitmentProof\n     * @instance\n     */\n\n    CommitmentProof.prototype.nonexist = null;\n    /**\n     * CommitmentProof batch.\n     * @member {ics23.IBatchProof|null|undefined} batch\n     * @memberof ics23.CommitmentProof\n     * @instance\n     */\n\n    CommitmentProof.prototype.batch = null;\n    /**\n     * CommitmentProof compressed.\n     * @member {ics23.ICompressedBatchProof|null|undefined} compressed\n     * @memberof ics23.CommitmentProof\n     * @instance\n     */\n\n    CommitmentProof.prototype.compressed = null; // OneOf field names bound to virtual getters and setters\n\n    var $oneOfFields;\n    /**\n     * CommitmentProof proof.\n     * @member {\"exist\"|\"nonexist\"|\"batch\"|\"compressed\"|undefined} proof\n     * @memberof ics23.CommitmentProof\n     * @instance\n     */\n\n    Object.defineProperty(CommitmentProof.prototype, \"proof\", {\n      get: $util.oneOfGetter($oneOfFields = [\"exist\", \"nonexist\", \"batch\", \"compressed\"]),\n      set: $util.oneOfSetter($oneOfFields)\n    });\n    /**\n     * Creates a new CommitmentProof instance using the specified properties.\n     * @function create\n     * @memberof ics23.CommitmentProof\n     * @static\n     * @param {ics23.ICommitmentProof=} [properties] Properties to set\n     * @returns {ics23.CommitmentProof} CommitmentProof instance\n     */\n\n    CommitmentProof.create = function create(properties) {\n      return new CommitmentProof(properties);\n    };\n    /**\n     * Encodes the specified CommitmentProof message. Does not implicitly {@link ics23.CommitmentProof.verify|verify} messages.\n     * @function encode\n     * @memberof ics23.CommitmentProof\n     * @static\n     * @param {ics23.ICommitmentProof} message CommitmentProof message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    CommitmentProof.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.exist != null && message.hasOwnProperty(\"exist\")) $root.ics23.ExistenceProof.encode(message.exist, writer.uint32(\n      /* id 1, wireType 2 =*/\n      10).fork()).ldelim();\n      if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) $root.ics23.NonExistenceProof.encode(message.nonexist, writer.uint32(\n      /* id 2, wireType 2 =*/\n      18).fork()).ldelim();\n      if (message.batch != null && message.hasOwnProperty(\"batch\")) $root.ics23.BatchProof.encode(message.batch, writer.uint32(\n      /* id 3, wireType 2 =*/\n      26).fork()).ldelim();\n      if (message.compressed != null && message.hasOwnProperty(\"compressed\")) $root.ics23.CompressedBatchProof.encode(message.compressed, writer.uint32(\n      /* id 4, wireType 2 =*/\n      34).fork()).ldelim();\n      return writer;\n    };\n    /**\n     * Encodes the specified CommitmentProof message, length delimited. Does not implicitly {@link ics23.CommitmentProof.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ics23.CommitmentProof\n     * @static\n     * @param {ics23.ICommitmentProof} message CommitmentProof message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    CommitmentProof.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes a CommitmentProof message from the specified reader or buffer.\n     * @function decode\n     * @memberof ics23.CommitmentProof\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ics23.CommitmentProof} CommitmentProof\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    CommitmentProof.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.ics23.CommitmentProof();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.exist = $root.ics23.ExistenceProof.decode(reader, reader.uint32());\n            break;\n\n          case 2:\n            message.nonexist = $root.ics23.NonExistenceProof.decode(reader, reader.uint32());\n            break;\n\n          case 3:\n            message.batch = $root.ics23.BatchProof.decode(reader, reader.uint32());\n            break;\n\n          case 4:\n            message.compressed = $root.ics23.CompressedBatchProof.decode(reader, reader.uint32());\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes a CommitmentProof message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ics23.CommitmentProof\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ics23.CommitmentProof} CommitmentProof\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    CommitmentProof.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies a CommitmentProof message.\n     * @function verify\n     * @memberof ics23.CommitmentProof\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    CommitmentProof.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n      var properties = {};\n\n      if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n        properties.proof = 1;\n        {\n          var error = $root.ics23.ExistenceProof.verify(message.exist);\n          if (error) return \"exist.\" + error;\n        }\n      }\n\n      if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n        if (properties.proof === 1) return \"proof: multiple values\";\n        properties.proof = 1;\n        {\n          var error = $root.ics23.NonExistenceProof.verify(message.nonexist);\n          if (error) return \"nonexist.\" + error;\n        }\n      }\n\n      if (message.batch != null && message.hasOwnProperty(\"batch\")) {\n        if (properties.proof === 1) return \"proof: multiple values\";\n        properties.proof = 1;\n        {\n          var error = $root.ics23.BatchProof.verify(message.batch);\n          if (error) return \"batch.\" + error;\n        }\n      }\n\n      if (message.compressed != null && message.hasOwnProperty(\"compressed\")) {\n        if (properties.proof === 1) return \"proof: multiple values\";\n        properties.proof = 1;\n        {\n          var error = $root.ics23.CompressedBatchProof.verify(message.compressed);\n          if (error) return \"compressed.\" + error;\n        }\n      }\n\n      return null;\n    };\n    /**\n     * Creates a CommitmentProof message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof ics23.CommitmentProof\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {ics23.CommitmentProof} CommitmentProof\n     */\n\n\n    CommitmentProof.fromObject = function fromObject(object) {\n      if (object instanceof $root.ics23.CommitmentProof) return object;\n      var message = new $root.ics23.CommitmentProof();\n\n      if (object.exist != null) {\n        if (typeof object.exist !== \"object\") throw TypeError(\".ics23.CommitmentProof.exist: object expected\");\n        message.exist = $root.ics23.ExistenceProof.fromObject(object.exist);\n      }\n\n      if (object.nonexist != null) {\n        if (typeof object.nonexist !== \"object\") throw TypeError(\".ics23.CommitmentProof.nonexist: object expected\");\n        message.nonexist = $root.ics23.NonExistenceProof.fromObject(object.nonexist);\n      }\n\n      if (object.batch != null) {\n        if (typeof object.batch !== \"object\") throw TypeError(\".ics23.CommitmentProof.batch: object expected\");\n        message.batch = $root.ics23.BatchProof.fromObject(object.batch);\n      }\n\n      if (object.compressed != null) {\n        if (typeof object.compressed !== \"object\") throw TypeError(\".ics23.CommitmentProof.compressed: object expected\");\n        message.compressed = $root.ics23.CompressedBatchProof.fromObject(object.compressed);\n      }\n\n      return message;\n    };\n    /**\n     * Creates a plain object from a CommitmentProof message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ics23.CommitmentProof\n     * @static\n     * @param {ics23.CommitmentProof} message CommitmentProof\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    CommitmentProof.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n\n      if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n        object.exist = $root.ics23.ExistenceProof.toObject(message.exist, options);\n        if (options.oneofs) object.proof = \"exist\";\n      }\n\n      if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n        object.nonexist = $root.ics23.NonExistenceProof.toObject(message.nonexist, options);\n        if (options.oneofs) object.proof = \"nonexist\";\n      }\n\n      if (message.batch != null && message.hasOwnProperty(\"batch\")) {\n        object.batch = $root.ics23.BatchProof.toObject(message.batch, options);\n        if (options.oneofs) object.proof = \"batch\";\n      }\n\n      if (message.compressed != null && message.hasOwnProperty(\"compressed\")) {\n        object.compressed = $root.ics23.CompressedBatchProof.toObject(message.compressed, options);\n        if (options.oneofs) object.proof = \"compressed\";\n      }\n\n      return object;\n    };\n    /**\n     * Converts this CommitmentProof to JSON.\n     * @function toJSON\n     * @memberof ics23.CommitmentProof\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    CommitmentProof.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return CommitmentProof;\n  }();\n\n  ics23.LeafOp = function () {\n    /**\n     * Properties of a LeafOp.\n     * @memberof ics23\n     * @interface ILeafOp\n     * @property {ics23.HashOp|null} [hash] LeafOp hash\n     * @property {ics23.HashOp|null} [prehashKey] LeafOp prehashKey\n     * @property {ics23.HashOp|null} [prehashValue] LeafOp prehashValue\n     * @property {ics23.LengthOp|null} [length] LeafOp length\n     * @property {Uint8Array|null} [prefix] LeafOp prefix\n     */\n\n    /**\n     * Constructs a new LeafOp.\n     * @memberof ics23\n     * @classdesc LeafOp represents the raw key-value data we wish to prove, and\n     * must be flexible to represent the internal transformation from\n     * the original key-value pairs into the basis hash, for many existing\n     * merkle trees.\n     * \n     * key and value are passed in. So that the signature of this operation is:\n     * leafOp(key, value) -> output\n     * \n     * To process this, first prehash the keys and values if needed (ANY means no hash in this case):\n     * hkey = prehashKey(key)\n     * hvalue = prehashValue(value)\n     * \n     * Then combine the bytes, and hash it\n     * output = hash(prefix || length(hkey) || hkey || length(hvalue) || hvalue)\n     * @implements ILeafOp\n     * @constructor\n     * @param {ics23.ILeafOp=} [properties] Properties to set\n     */\n    function LeafOp(properties) {\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * LeafOp hash.\n     * @member {ics23.HashOp} hash\n     * @memberof ics23.LeafOp\n     * @instance\n     */\n\n\n    LeafOp.prototype.hash = 0;\n    /**\n     * LeafOp prehashKey.\n     * @member {ics23.HashOp} prehashKey\n     * @memberof ics23.LeafOp\n     * @instance\n     */\n\n    LeafOp.prototype.prehashKey = 0;\n    /**\n     * LeafOp prehashValue.\n     * @member {ics23.HashOp} prehashValue\n     * @memberof ics23.LeafOp\n     * @instance\n     */\n\n    LeafOp.prototype.prehashValue = 0;\n    /**\n     * LeafOp length.\n     * @member {ics23.LengthOp} length\n     * @memberof ics23.LeafOp\n     * @instance\n     */\n\n    LeafOp.prototype.length = 0;\n    /**\n     * LeafOp prefix.\n     * @member {Uint8Array} prefix\n     * @memberof ics23.LeafOp\n     * @instance\n     */\n\n    LeafOp.prototype.prefix = $util.newBuffer([]);\n    /**\n     * Creates a new LeafOp instance using the specified properties.\n     * @function create\n     * @memberof ics23.LeafOp\n     * @static\n     * @param {ics23.ILeafOp=} [properties] Properties to set\n     * @returns {ics23.LeafOp} LeafOp instance\n     */\n\n    LeafOp.create = function create(properties) {\n      return new LeafOp(properties);\n    };\n    /**\n     * Encodes the specified LeafOp message. Does not implicitly {@link ics23.LeafOp.verify|verify} messages.\n     * @function encode\n     * @memberof ics23.LeafOp\n     * @static\n     * @param {ics23.ILeafOp} message LeafOp message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    LeafOp.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.hash != null && message.hasOwnProperty(\"hash\")) writer.uint32(\n      /* id 1, wireType 0 =*/\n      8).int32(message.hash);\n      if (message.prehashKey != null && message.hasOwnProperty(\"prehashKey\")) writer.uint32(\n      /* id 2, wireType 0 =*/\n      16).int32(message.prehashKey);\n      if (message.prehashValue != null && message.hasOwnProperty(\"prehashValue\")) writer.uint32(\n      /* id 3, wireType 0 =*/\n      24).int32(message.prehashValue);\n      if (message.length != null && message.hasOwnProperty(\"length\")) writer.uint32(\n      /* id 4, wireType 0 =*/\n      32).int32(message.length);\n      if (message.prefix != null && message.hasOwnProperty(\"prefix\")) writer.uint32(\n      /* id 5, wireType 2 =*/\n      42).bytes(message.prefix);\n      return writer;\n    };\n    /**\n     * Encodes the specified LeafOp message, length delimited. Does not implicitly {@link ics23.LeafOp.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ics23.LeafOp\n     * @static\n     * @param {ics23.ILeafOp} message LeafOp message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    LeafOp.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes a LeafOp message from the specified reader or buffer.\n     * @function decode\n     * @memberof ics23.LeafOp\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ics23.LeafOp} LeafOp\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    LeafOp.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.ics23.LeafOp();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.hash = reader.int32();\n            break;\n\n          case 2:\n            message.prehashKey = reader.int32();\n            break;\n\n          case 3:\n            message.prehashValue = reader.int32();\n            break;\n\n          case 4:\n            message.length = reader.int32();\n            break;\n\n          case 5:\n            message.prefix = reader.bytes();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes a LeafOp message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ics23.LeafOp\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ics23.LeafOp} LeafOp\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    LeafOp.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies a LeafOp message.\n     * @function verify\n     * @memberof ics23.LeafOp\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    LeafOp.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n      if (message.hash != null && message.hasOwnProperty(\"hash\")) switch (message.hash) {\n        default:\n          return \"hash: enum value expected\";\n\n        case 0:\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n          break;\n      }\n      if (message.prehashKey != null && message.hasOwnProperty(\"prehashKey\")) switch (message.prehashKey) {\n        default:\n          return \"prehashKey: enum value expected\";\n\n        case 0:\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n          break;\n      }\n      if (message.prehashValue != null && message.hasOwnProperty(\"prehashValue\")) switch (message.prehashValue) {\n        default:\n          return \"prehashValue: enum value expected\";\n\n        case 0:\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n          break;\n      }\n      if (message.length != null && message.hasOwnProperty(\"length\")) switch (message.length) {\n        default:\n          return \"length: enum value expected\";\n\n        case 0:\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n          break;\n      }\n      if (message.prefix != null && message.hasOwnProperty(\"prefix\")) if (!(message.prefix && typeof message.prefix.length === \"number\" || $util.isString(message.prefix))) return \"prefix: buffer expected\";\n      return null;\n    };\n    /**\n     * Creates a LeafOp message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof ics23.LeafOp\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {ics23.LeafOp} LeafOp\n     */\n\n\n    LeafOp.fromObject = function fromObject(object) {\n      if (object instanceof $root.ics23.LeafOp) return object;\n      var message = new $root.ics23.LeafOp();\n\n      switch (object.hash) {\n        case \"NO_HASH\":\n        case 0:\n          message.hash = 0;\n          break;\n\n        case \"SHA256\":\n        case 1:\n          message.hash = 1;\n          break;\n\n        case \"SHA512\":\n        case 2:\n          message.hash = 2;\n          break;\n\n        case \"KECCAK\":\n        case 3:\n          message.hash = 3;\n          break;\n\n        case \"RIPEMD160\":\n        case 4:\n          message.hash = 4;\n          break;\n\n        case \"BITCOIN\":\n        case 5:\n          message.hash = 5;\n          break;\n\n        case \"SHA512_256\":\n        case 6:\n          message.hash = 6;\n          break;\n      }\n\n      switch (object.prehashKey) {\n        case \"NO_HASH\":\n        case 0:\n          message.prehashKey = 0;\n          break;\n\n        case \"SHA256\":\n        case 1:\n          message.prehashKey = 1;\n          break;\n\n        case \"SHA512\":\n        case 2:\n          message.prehashKey = 2;\n          break;\n\n        case \"KECCAK\":\n        case 3:\n          message.prehashKey = 3;\n          break;\n\n        case \"RIPEMD160\":\n        case 4:\n          message.prehashKey = 4;\n          break;\n\n        case \"BITCOIN\":\n        case 5:\n          message.prehashKey = 5;\n          break;\n\n        case \"SHA512_256\":\n        case 6:\n          message.prehashKey = 6;\n          break;\n      }\n\n      switch (object.prehashValue) {\n        case \"NO_HASH\":\n        case 0:\n          message.prehashValue = 0;\n          break;\n\n        case \"SHA256\":\n        case 1:\n          message.prehashValue = 1;\n          break;\n\n        case \"SHA512\":\n        case 2:\n          message.prehashValue = 2;\n          break;\n\n        case \"KECCAK\":\n        case 3:\n          message.prehashValue = 3;\n          break;\n\n        case \"RIPEMD160\":\n        case 4:\n          message.prehashValue = 4;\n          break;\n\n        case \"BITCOIN\":\n        case 5:\n          message.prehashValue = 5;\n          break;\n\n        case \"SHA512_256\":\n        case 6:\n          message.prehashValue = 6;\n          break;\n      }\n\n      switch (object.length) {\n        case \"NO_PREFIX\":\n        case 0:\n          message.length = 0;\n          break;\n\n        case \"VAR_PROTO\":\n        case 1:\n          message.length = 1;\n          break;\n\n        case \"VAR_RLP\":\n        case 2:\n          message.length = 2;\n          break;\n\n        case \"FIXED32_BIG\":\n        case 3:\n          message.length = 3;\n          break;\n\n        case \"FIXED32_LITTLE\":\n        case 4:\n          message.length = 4;\n          break;\n\n        case \"FIXED64_BIG\":\n        case 5:\n          message.length = 5;\n          break;\n\n        case \"FIXED64_LITTLE\":\n        case 6:\n          message.length = 6;\n          break;\n\n        case \"REQUIRE_32_BYTES\":\n        case 7:\n          message.length = 7;\n          break;\n\n        case \"REQUIRE_64_BYTES\":\n        case 8:\n          message.length = 8;\n          break;\n      }\n\n      if (object.prefix != null) if (typeof object.prefix === \"string\") $util.base64.decode(object.prefix, message.prefix = $util.newBuffer($util.base64.length(object.prefix)), 0);else if (object.prefix.length) message.prefix = object.prefix;\n      return message;\n    };\n    /**\n     * Creates a plain object from a LeafOp message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ics23.LeafOp\n     * @static\n     * @param {ics23.LeafOp} message LeafOp\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    LeafOp.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n\n      if (options.defaults) {\n        object.hash = options.enums === String ? \"NO_HASH\" : 0;\n        object.prehashKey = options.enums === String ? \"NO_HASH\" : 0;\n        object.prehashValue = options.enums === String ? \"NO_HASH\" : 0;\n        object.length = options.enums === String ? \"NO_PREFIX\" : 0;\n        if (options.bytes === String) object.prefix = \"\";else {\n          object.prefix = [];\n          if (options.bytes !== Array) object.prefix = $util.newBuffer(object.prefix);\n        }\n      }\n\n      if (message.hash != null && message.hasOwnProperty(\"hash\")) object.hash = options.enums === String ? $root.ics23.HashOp[message.hash] : message.hash;\n      if (message.prehashKey != null && message.hasOwnProperty(\"prehashKey\")) object.prehashKey = options.enums === String ? $root.ics23.HashOp[message.prehashKey] : message.prehashKey;\n      if (message.prehashValue != null && message.hasOwnProperty(\"prehashValue\")) object.prehashValue = options.enums === String ? $root.ics23.HashOp[message.prehashValue] : message.prehashValue;\n      if (message.length != null && message.hasOwnProperty(\"length\")) object.length = options.enums === String ? $root.ics23.LengthOp[message.length] : message.length;\n      if (message.prefix != null && message.hasOwnProperty(\"prefix\")) object.prefix = options.bytes === String ? $util.base64.encode(message.prefix, 0, message.prefix.length) : options.bytes === Array ? Array.prototype.slice.call(message.prefix) : message.prefix;\n      return object;\n    };\n    /**\n     * Converts this LeafOp to JSON.\n     * @function toJSON\n     * @memberof ics23.LeafOp\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    LeafOp.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return LeafOp;\n  }();\n\n  ics23.InnerOp = function () {\n    /**\n     * Properties of an InnerOp.\n     * @memberof ics23\n     * @interface IInnerOp\n     * @property {ics23.HashOp|null} [hash] InnerOp hash\n     * @property {Uint8Array|null} [prefix] InnerOp prefix\n     * @property {Uint8Array|null} [suffix] InnerOp suffix\n     */\n\n    /**\n     * Constructs a new InnerOp.\n     * @memberof ics23\n     * @classdesc InnerOp represents a merkle-proof step that is not a leaf.\n     * It represents concatenating two children and hashing them to provide the next result.\n     * \n     * The result of the previous step is passed in, so the signature of this op is:\n     * innerOp(child) -> output\n     * \n     * The result of applying InnerOp should be:\n     * output = op.hash(op.prefix || child || op.suffix)\n     * \n     * where the || operator is concatenation of binary data,\n     * and child is the result of hashing all the tree below this step.\n     * \n     * Any special data, like prepending child with the length, or prepending the entire operation with\n     * some value to differentiate from leaf nodes, should be included in prefix and suffix.\n     * If either of prefix or suffix is empty, we just treat it as an empty string\n     * @implements IInnerOp\n     * @constructor\n     * @param {ics23.IInnerOp=} [properties] Properties to set\n     */\n    function InnerOp(properties) {\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * InnerOp hash.\n     * @member {ics23.HashOp} hash\n     * @memberof ics23.InnerOp\n     * @instance\n     */\n\n\n    InnerOp.prototype.hash = 0;\n    /**\n     * InnerOp prefix.\n     * @member {Uint8Array} prefix\n     * @memberof ics23.InnerOp\n     * @instance\n     */\n\n    InnerOp.prototype.prefix = $util.newBuffer([]);\n    /**\n     * InnerOp suffix.\n     * @member {Uint8Array} suffix\n     * @memberof ics23.InnerOp\n     * @instance\n     */\n\n    InnerOp.prototype.suffix = $util.newBuffer([]);\n    /**\n     * Creates a new InnerOp instance using the specified properties.\n     * @function create\n     * @memberof ics23.InnerOp\n     * @static\n     * @param {ics23.IInnerOp=} [properties] Properties to set\n     * @returns {ics23.InnerOp} InnerOp instance\n     */\n\n    InnerOp.create = function create(properties) {\n      return new InnerOp(properties);\n    };\n    /**\n     * Encodes the specified InnerOp message. Does not implicitly {@link ics23.InnerOp.verify|verify} messages.\n     * @function encode\n     * @memberof ics23.InnerOp\n     * @static\n     * @param {ics23.IInnerOp} message InnerOp message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    InnerOp.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.hash != null && message.hasOwnProperty(\"hash\")) writer.uint32(\n      /* id 1, wireType 0 =*/\n      8).int32(message.hash);\n      if (message.prefix != null && message.hasOwnProperty(\"prefix\")) writer.uint32(\n      /* id 2, wireType 2 =*/\n      18).bytes(message.prefix);\n      if (message.suffix != null && message.hasOwnProperty(\"suffix\")) writer.uint32(\n      /* id 3, wireType 2 =*/\n      26).bytes(message.suffix);\n      return writer;\n    };\n    /**\n     * Encodes the specified InnerOp message, length delimited. Does not implicitly {@link ics23.InnerOp.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ics23.InnerOp\n     * @static\n     * @param {ics23.IInnerOp} message InnerOp message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    InnerOp.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes an InnerOp message from the specified reader or buffer.\n     * @function decode\n     * @memberof ics23.InnerOp\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ics23.InnerOp} InnerOp\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    InnerOp.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.ics23.InnerOp();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.hash = reader.int32();\n            break;\n\n          case 2:\n            message.prefix = reader.bytes();\n            break;\n\n          case 3:\n            message.suffix = reader.bytes();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes an InnerOp message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ics23.InnerOp\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ics23.InnerOp} InnerOp\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    InnerOp.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies an InnerOp message.\n     * @function verify\n     * @memberof ics23.InnerOp\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    InnerOp.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n      if (message.hash != null && message.hasOwnProperty(\"hash\")) switch (message.hash) {\n        default:\n          return \"hash: enum value expected\";\n\n        case 0:\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n          break;\n      }\n      if (message.prefix != null && message.hasOwnProperty(\"prefix\")) if (!(message.prefix && typeof message.prefix.length === \"number\" || $util.isString(message.prefix))) return \"prefix: buffer expected\";\n      if (message.suffix != null && message.hasOwnProperty(\"suffix\")) if (!(message.suffix && typeof message.suffix.length === \"number\" || $util.isString(message.suffix))) return \"suffix: buffer expected\";\n      return null;\n    };\n    /**\n     * Creates an InnerOp message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof ics23.InnerOp\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {ics23.InnerOp} InnerOp\n     */\n\n\n    InnerOp.fromObject = function fromObject(object) {\n      if (object instanceof $root.ics23.InnerOp) return object;\n      var message = new $root.ics23.InnerOp();\n\n      switch (object.hash) {\n        case \"NO_HASH\":\n        case 0:\n          message.hash = 0;\n          break;\n\n        case \"SHA256\":\n        case 1:\n          message.hash = 1;\n          break;\n\n        case \"SHA512\":\n        case 2:\n          message.hash = 2;\n          break;\n\n        case \"KECCAK\":\n        case 3:\n          message.hash = 3;\n          break;\n\n        case \"RIPEMD160\":\n        case 4:\n          message.hash = 4;\n          break;\n\n        case \"BITCOIN\":\n        case 5:\n          message.hash = 5;\n          break;\n\n        case \"SHA512_256\":\n        case 6:\n          message.hash = 6;\n          break;\n      }\n\n      if (object.prefix != null) if (typeof object.prefix === \"string\") $util.base64.decode(object.prefix, message.prefix = $util.newBuffer($util.base64.length(object.prefix)), 0);else if (object.prefix.length) message.prefix = object.prefix;\n      if (object.suffix != null) if (typeof object.suffix === \"string\") $util.base64.decode(object.suffix, message.suffix = $util.newBuffer($util.base64.length(object.suffix)), 0);else if (object.suffix.length) message.suffix = object.suffix;\n      return message;\n    };\n    /**\n     * Creates a plain object from an InnerOp message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ics23.InnerOp\n     * @static\n     * @param {ics23.InnerOp} message InnerOp\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    InnerOp.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n\n      if (options.defaults) {\n        object.hash = options.enums === String ? \"NO_HASH\" : 0;\n        if (options.bytes === String) object.prefix = \"\";else {\n          object.prefix = [];\n          if (options.bytes !== Array) object.prefix = $util.newBuffer(object.prefix);\n        }\n        if (options.bytes === String) object.suffix = \"\";else {\n          object.suffix = [];\n          if (options.bytes !== Array) object.suffix = $util.newBuffer(object.suffix);\n        }\n      }\n\n      if (message.hash != null && message.hasOwnProperty(\"hash\")) object.hash = options.enums === String ? $root.ics23.HashOp[message.hash] : message.hash;\n      if (message.prefix != null && message.hasOwnProperty(\"prefix\")) object.prefix = options.bytes === String ? $util.base64.encode(message.prefix, 0, message.prefix.length) : options.bytes === Array ? Array.prototype.slice.call(message.prefix) : message.prefix;\n      if (message.suffix != null && message.hasOwnProperty(\"suffix\")) object.suffix = options.bytes === String ? $util.base64.encode(message.suffix, 0, message.suffix.length) : options.bytes === Array ? Array.prototype.slice.call(message.suffix) : message.suffix;\n      return object;\n    };\n    /**\n     * Converts this InnerOp to JSON.\n     * @function toJSON\n     * @memberof ics23.InnerOp\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    InnerOp.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return InnerOp;\n  }();\n\n  ics23.ProofSpec = function () {\n    /**\n     * Properties of a ProofSpec.\n     * @memberof ics23\n     * @interface IProofSpec\n     * @property {ics23.ILeafOp|null} [leafSpec] ProofSpec leafSpec\n     * @property {ics23.IInnerSpec|null} [innerSpec] ProofSpec innerSpec\n     * @property {number|null} [maxDepth] ProofSpec maxDepth\n     * @property {number|null} [minDepth] ProofSpec minDepth\n     */\n\n    /**\n     * Constructs a new ProofSpec.\n     * @memberof ics23\n     * @classdesc ProofSpec defines what the expected parameters are for a given proof type.\n     * This can be stored in the client and used to validate any incoming proofs.\n     * \n     * verify(ProofSpec, Proof) -> Proof | Error\n     * \n     * As demonstrated in tests, if we don't fix the algorithm used to calculate the\n     * LeafHash for a given tree, there are many possible key-value pairs that can\n     * generate a given hash (by interpretting the preimage differently).\n     * We need this for proper security, requires client knows a priori what\n     * tree format server uses. But not in code, rather a configuration object.\n     * @implements IProofSpec\n     * @constructor\n     * @param {ics23.IProofSpec=} [properties] Properties to set\n     */\n    function ProofSpec(properties) {\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * ProofSpec leafSpec.\n     * @member {ics23.ILeafOp|null|undefined} leafSpec\n     * @memberof ics23.ProofSpec\n     * @instance\n     */\n\n\n    ProofSpec.prototype.leafSpec = null;\n    /**\n     * ProofSpec innerSpec.\n     * @member {ics23.IInnerSpec|null|undefined} innerSpec\n     * @memberof ics23.ProofSpec\n     * @instance\n     */\n\n    ProofSpec.prototype.innerSpec = null;\n    /**\n     * ProofSpec maxDepth.\n     * @member {number} maxDepth\n     * @memberof ics23.ProofSpec\n     * @instance\n     */\n\n    ProofSpec.prototype.maxDepth = 0;\n    /**\n     * ProofSpec minDepth.\n     * @member {number} minDepth\n     * @memberof ics23.ProofSpec\n     * @instance\n     */\n\n    ProofSpec.prototype.minDepth = 0;\n    /**\n     * Creates a new ProofSpec instance using the specified properties.\n     * @function create\n     * @memberof ics23.ProofSpec\n     * @static\n     * @param {ics23.IProofSpec=} [properties] Properties to set\n     * @returns {ics23.ProofSpec} ProofSpec instance\n     */\n\n    ProofSpec.create = function create(properties) {\n      return new ProofSpec(properties);\n    };\n    /**\n     * Encodes the specified ProofSpec message. Does not implicitly {@link ics23.ProofSpec.verify|verify} messages.\n     * @function encode\n     * @memberof ics23.ProofSpec\n     * @static\n     * @param {ics23.IProofSpec} message ProofSpec message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    ProofSpec.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.leafSpec != null && message.hasOwnProperty(\"leafSpec\")) $root.ics23.LeafOp.encode(message.leafSpec, writer.uint32(\n      /* id 1, wireType 2 =*/\n      10).fork()).ldelim();\n      if (message.innerSpec != null && message.hasOwnProperty(\"innerSpec\")) $root.ics23.InnerSpec.encode(message.innerSpec, writer.uint32(\n      /* id 2, wireType 2 =*/\n      18).fork()).ldelim();\n      if (message.maxDepth != null && message.hasOwnProperty(\"maxDepth\")) writer.uint32(\n      /* id 3, wireType 0 =*/\n      24).int32(message.maxDepth);\n      if (message.minDepth != null && message.hasOwnProperty(\"minDepth\")) writer.uint32(\n      /* id 4, wireType 0 =*/\n      32).int32(message.minDepth);\n      return writer;\n    };\n    /**\n     * Encodes the specified ProofSpec message, length delimited. Does not implicitly {@link ics23.ProofSpec.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ics23.ProofSpec\n     * @static\n     * @param {ics23.IProofSpec} message ProofSpec message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    ProofSpec.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes a ProofSpec message from the specified reader or buffer.\n     * @function decode\n     * @memberof ics23.ProofSpec\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ics23.ProofSpec} ProofSpec\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    ProofSpec.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.ics23.ProofSpec();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.leafSpec = $root.ics23.LeafOp.decode(reader, reader.uint32());\n            break;\n\n          case 2:\n            message.innerSpec = $root.ics23.InnerSpec.decode(reader, reader.uint32());\n            break;\n\n          case 3:\n            message.maxDepth = reader.int32();\n            break;\n\n          case 4:\n            message.minDepth = reader.int32();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes a ProofSpec message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ics23.ProofSpec\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ics23.ProofSpec} ProofSpec\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    ProofSpec.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies a ProofSpec message.\n     * @function verify\n     * @memberof ics23.ProofSpec\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    ProofSpec.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n      if (message.leafSpec != null && message.hasOwnProperty(\"leafSpec\")) {\n        var error = $root.ics23.LeafOp.verify(message.leafSpec);\n        if (error) return \"leafSpec.\" + error;\n      }\n\n      if (message.innerSpec != null && message.hasOwnProperty(\"innerSpec\")) {\n        var error = $root.ics23.InnerSpec.verify(message.innerSpec);\n        if (error) return \"innerSpec.\" + error;\n      }\n\n      if (message.maxDepth != null && message.hasOwnProperty(\"maxDepth\")) if (!$util.isInteger(message.maxDepth)) return \"maxDepth: integer expected\";\n      if (message.minDepth != null && message.hasOwnProperty(\"minDepth\")) if (!$util.isInteger(message.minDepth)) return \"minDepth: integer expected\";\n      return null;\n    };\n    /**\n     * Creates a ProofSpec message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof ics23.ProofSpec\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {ics23.ProofSpec} ProofSpec\n     */\n\n\n    ProofSpec.fromObject = function fromObject(object) {\n      if (object instanceof $root.ics23.ProofSpec) return object;\n      var message = new $root.ics23.ProofSpec();\n\n      if (object.leafSpec != null) {\n        if (typeof object.leafSpec !== \"object\") throw TypeError(\".ics23.ProofSpec.leafSpec: object expected\");\n        message.leafSpec = $root.ics23.LeafOp.fromObject(object.leafSpec);\n      }\n\n      if (object.innerSpec != null) {\n        if (typeof object.innerSpec !== \"object\") throw TypeError(\".ics23.ProofSpec.innerSpec: object expected\");\n        message.innerSpec = $root.ics23.InnerSpec.fromObject(object.innerSpec);\n      }\n\n      if (object.maxDepth != null) message.maxDepth = object.maxDepth | 0;\n      if (object.minDepth != null) message.minDepth = object.minDepth | 0;\n      return message;\n    };\n    /**\n     * Creates a plain object from a ProofSpec message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ics23.ProofSpec\n     * @static\n     * @param {ics23.ProofSpec} message ProofSpec\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    ProofSpec.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n\n      if (options.defaults) {\n        object.leafSpec = null;\n        object.innerSpec = null;\n        object.maxDepth = 0;\n        object.minDepth = 0;\n      }\n\n      if (message.leafSpec != null && message.hasOwnProperty(\"leafSpec\")) object.leafSpec = $root.ics23.LeafOp.toObject(message.leafSpec, options);\n      if (message.innerSpec != null && message.hasOwnProperty(\"innerSpec\")) object.innerSpec = $root.ics23.InnerSpec.toObject(message.innerSpec, options);\n      if (message.maxDepth != null && message.hasOwnProperty(\"maxDepth\")) object.maxDepth = message.maxDepth;\n      if (message.minDepth != null && message.hasOwnProperty(\"minDepth\")) object.minDepth = message.minDepth;\n      return object;\n    };\n    /**\n     * Converts this ProofSpec to JSON.\n     * @function toJSON\n     * @memberof ics23.ProofSpec\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    ProofSpec.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return ProofSpec;\n  }();\n\n  ics23.InnerSpec = function () {\n    /**\n     * Properties of an InnerSpec.\n     * @memberof ics23\n     * @interface IInnerSpec\n     * @property {Array.<number>|null} [childOrder] InnerSpec childOrder\n     * @property {number|null} [childSize] InnerSpec childSize\n     * @property {number|null} [minPrefixLength] InnerSpec minPrefixLength\n     * @property {number|null} [maxPrefixLength] InnerSpec maxPrefixLength\n     * @property {Uint8Array|null} [emptyChild] InnerSpec emptyChild\n     * @property {ics23.HashOp|null} [hash] InnerSpec hash\n     */\n\n    /**\n     * Constructs a new InnerSpec.\n     * @memberof ics23\n     * @classdesc Represents an InnerSpec.\n     * @implements IInnerSpec\n     * @constructor\n     * @param {ics23.IInnerSpec=} [properties] Properties to set\n     */\n    function InnerSpec(properties) {\n      this.childOrder = [];\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * InnerSpec childOrder.\n     * @member {Array.<number>} childOrder\n     * @memberof ics23.InnerSpec\n     * @instance\n     */\n\n\n    InnerSpec.prototype.childOrder = $util.emptyArray;\n    /**\n     * InnerSpec childSize.\n     * @member {number} childSize\n     * @memberof ics23.InnerSpec\n     * @instance\n     */\n\n    InnerSpec.prototype.childSize = 0;\n    /**\n     * InnerSpec minPrefixLength.\n     * @member {number} minPrefixLength\n     * @memberof ics23.InnerSpec\n     * @instance\n     */\n\n    InnerSpec.prototype.minPrefixLength = 0;\n    /**\n     * InnerSpec maxPrefixLength.\n     * @member {number} maxPrefixLength\n     * @memberof ics23.InnerSpec\n     * @instance\n     */\n\n    InnerSpec.prototype.maxPrefixLength = 0;\n    /**\n     * InnerSpec emptyChild.\n     * @member {Uint8Array} emptyChild\n     * @memberof ics23.InnerSpec\n     * @instance\n     */\n\n    InnerSpec.prototype.emptyChild = $util.newBuffer([]);\n    /**\n     * InnerSpec hash.\n     * @member {ics23.HashOp} hash\n     * @memberof ics23.InnerSpec\n     * @instance\n     */\n\n    InnerSpec.prototype.hash = 0;\n    /**\n     * Creates a new InnerSpec instance using the specified properties.\n     * @function create\n     * @memberof ics23.InnerSpec\n     * @static\n     * @param {ics23.IInnerSpec=} [properties] Properties to set\n     * @returns {ics23.InnerSpec} InnerSpec instance\n     */\n\n    InnerSpec.create = function create(properties) {\n      return new InnerSpec(properties);\n    };\n    /**\n     * Encodes the specified InnerSpec message. Does not implicitly {@link ics23.InnerSpec.verify|verify} messages.\n     * @function encode\n     * @memberof ics23.InnerSpec\n     * @static\n     * @param {ics23.IInnerSpec} message InnerSpec message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    InnerSpec.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n\n      if (message.childOrder != null && message.childOrder.length) {\n        writer.uint32(\n        /* id 1, wireType 2 =*/\n        10).fork();\n\n        for (var i = 0; i < message.childOrder.length; ++i) writer.int32(message.childOrder[i]);\n\n        writer.ldelim();\n      }\n\n      if (message.childSize != null && message.hasOwnProperty(\"childSize\")) writer.uint32(\n      /* id 2, wireType 0 =*/\n      16).int32(message.childSize);\n      if (message.minPrefixLength != null && message.hasOwnProperty(\"minPrefixLength\")) writer.uint32(\n      /* id 3, wireType 0 =*/\n      24).int32(message.minPrefixLength);\n      if (message.maxPrefixLength != null && message.hasOwnProperty(\"maxPrefixLength\")) writer.uint32(\n      /* id 4, wireType 0 =*/\n      32).int32(message.maxPrefixLength);\n      if (message.emptyChild != null && message.hasOwnProperty(\"emptyChild\")) writer.uint32(\n      /* id 5, wireType 2 =*/\n      42).bytes(message.emptyChild);\n      if (message.hash != null && message.hasOwnProperty(\"hash\")) writer.uint32(\n      /* id 6, wireType 0 =*/\n      48).int32(message.hash);\n      return writer;\n    };\n    /**\n     * Encodes the specified InnerSpec message, length delimited. Does not implicitly {@link ics23.InnerSpec.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ics23.InnerSpec\n     * @static\n     * @param {ics23.IInnerSpec} message InnerSpec message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    InnerSpec.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes an InnerSpec message from the specified reader or buffer.\n     * @function decode\n     * @memberof ics23.InnerSpec\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ics23.InnerSpec} InnerSpec\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    InnerSpec.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.ics23.InnerSpec();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            if (!(message.childOrder && message.childOrder.length)) message.childOrder = [];\n\n            if ((tag & 7) === 2) {\n              var end2 = reader.uint32() + reader.pos;\n\n              while (reader.pos < end2) message.childOrder.push(reader.int32());\n            } else message.childOrder.push(reader.int32());\n\n            break;\n\n          case 2:\n            message.childSize = reader.int32();\n            break;\n\n          case 3:\n            message.minPrefixLength = reader.int32();\n            break;\n\n          case 4:\n            message.maxPrefixLength = reader.int32();\n            break;\n\n          case 5:\n            message.emptyChild = reader.bytes();\n            break;\n\n          case 6:\n            message.hash = reader.int32();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes an InnerSpec message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ics23.InnerSpec\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ics23.InnerSpec} InnerSpec\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    InnerSpec.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies an InnerSpec message.\n     * @function verify\n     * @memberof ics23.InnerSpec\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    InnerSpec.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n      if (message.childOrder != null && message.hasOwnProperty(\"childOrder\")) {\n        if (!Array.isArray(message.childOrder)) return \"childOrder: array expected\";\n\n        for (var i = 0; i < message.childOrder.length; ++i) if (!$util.isInteger(message.childOrder[i])) return \"childOrder: integer[] expected\";\n      }\n\n      if (message.childSize != null && message.hasOwnProperty(\"childSize\")) if (!$util.isInteger(message.childSize)) return \"childSize: integer expected\";\n      if (message.minPrefixLength != null && message.hasOwnProperty(\"minPrefixLength\")) if (!$util.isInteger(message.minPrefixLength)) return \"minPrefixLength: integer expected\";\n      if (message.maxPrefixLength != null && message.hasOwnProperty(\"maxPrefixLength\")) if (!$util.isInteger(message.maxPrefixLength)) return \"maxPrefixLength: integer expected\";\n      if (message.emptyChild != null && message.hasOwnProperty(\"emptyChild\")) if (!(message.emptyChild && typeof message.emptyChild.length === \"number\" || $util.isString(message.emptyChild))) return \"emptyChild: buffer expected\";\n      if (message.hash != null && message.hasOwnProperty(\"hash\")) switch (message.hash) {\n        default:\n          return \"hash: enum value expected\";\n\n        case 0:\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n          break;\n      }\n      return null;\n    };\n    /**\n     * Creates an InnerSpec message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof ics23.InnerSpec\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {ics23.InnerSpec} InnerSpec\n     */\n\n\n    InnerSpec.fromObject = function fromObject(object) {\n      if (object instanceof $root.ics23.InnerSpec) return object;\n      var message = new $root.ics23.InnerSpec();\n\n      if (object.childOrder) {\n        if (!Array.isArray(object.childOrder)) throw TypeError(\".ics23.InnerSpec.childOrder: array expected\");\n        message.childOrder = [];\n\n        for (var i = 0; i < object.childOrder.length; ++i) message.childOrder[i] = object.childOrder[i] | 0;\n      }\n\n      if (object.childSize != null) message.childSize = object.childSize | 0;\n      if (object.minPrefixLength != null) message.minPrefixLength = object.minPrefixLength | 0;\n      if (object.maxPrefixLength != null) message.maxPrefixLength = object.maxPrefixLength | 0;\n      if (object.emptyChild != null) if (typeof object.emptyChild === \"string\") $util.base64.decode(object.emptyChild, message.emptyChild = $util.newBuffer($util.base64.length(object.emptyChild)), 0);else if (object.emptyChild.length) message.emptyChild = object.emptyChild;\n\n      switch (object.hash) {\n        case \"NO_HASH\":\n        case 0:\n          message.hash = 0;\n          break;\n\n        case \"SHA256\":\n        case 1:\n          message.hash = 1;\n          break;\n\n        case \"SHA512\":\n        case 2:\n          message.hash = 2;\n          break;\n\n        case \"KECCAK\":\n        case 3:\n          message.hash = 3;\n          break;\n\n        case \"RIPEMD160\":\n        case 4:\n          message.hash = 4;\n          break;\n\n        case \"BITCOIN\":\n        case 5:\n          message.hash = 5;\n          break;\n\n        case \"SHA512_256\":\n        case 6:\n          message.hash = 6;\n          break;\n      }\n\n      return message;\n    };\n    /**\n     * Creates a plain object from an InnerSpec message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ics23.InnerSpec\n     * @static\n     * @param {ics23.InnerSpec} message InnerSpec\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    InnerSpec.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.arrays || options.defaults) object.childOrder = [];\n\n      if (options.defaults) {\n        object.childSize = 0;\n        object.minPrefixLength = 0;\n        object.maxPrefixLength = 0;\n        if (options.bytes === String) object.emptyChild = \"\";else {\n          object.emptyChild = [];\n          if (options.bytes !== Array) object.emptyChild = $util.newBuffer(object.emptyChild);\n        }\n        object.hash = options.enums === String ? \"NO_HASH\" : 0;\n      }\n\n      if (message.childOrder && message.childOrder.length) {\n        object.childOrder = [];\n\n        for (var j = 0; j < message.childOrder.length; ++j) object.childOrder[j] = message.childOrder[j];\n      }\n\n      if (message.childSize != null && message.hasOwnProperty(\"childSize\")) object.childSize = message.childSize;\n      if (message.minPrefixLength != null && message.hasOwnProperty(\"minPrefixLength\")) object.minPrefixLength = message.minPrefixLength;\n      if (message.maxPrefixLength != null && message.hasOwnProperty(\"maxPrefixLength\")) object.maxPrefixLength = message.maxPrefixLength;\n      if (message.emptyChild != null && message.hasOwnProperty(\"emptyChild\")) object.emptyChild = options.bytes === String ? $util.base64.encode(message.emptyChild, 0, message.emptyChild.length) : options.bytes === Array ? Array.prototype.slice.call(message.emptyChild) : message.emptyChild;\n      if (message.hash != null && message.hasOwnProperty(\"hash\")) object.hash = options.enums === String ? $root.ics23.HashOp[message.hash] : message.hash;\n      return object;\n    };\n    /**\n     * Converts this InnerSpec to JSON.\n     * @function toJSON\n     * @memberof ics23.InnerSpec\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    InnerSpec.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return InnerSpec;\n  }();\n\n  ics23.BatchProof = function () {\n    /**\n     * Properties of a BatchProof.\n     * @memberof ics23\n     * @interface IBatchProof\n     * @property {Array.<ics23.IBatchEntry>|null} [entries] BatchProof entries\n     */\n\n    /**\n     * Constructs a new BatchProof.\n     * @memberof ics23\n     * @classdesc Represents a BatchProof.\n     * @implements IBatchProof\n     * @constructor\n     * @param {ics23.IBatchProof=} [properties] Properties to set\n     */\n    function BatchProof(properties) {\n      this.entries = [];\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * BatchProof entries.\n     * @member {Array.<ics23.IBatchEntry>} entries\n     * @memberof ics23.BatchProof\n     * @instance\n     */\n\n\n    BatchProof.prototype.entries = $util.emptyArray;\n    /**\n     * Creates a new BatchProof instance using the specified properties.\n     * @function create\n     * @memberof ics23.BatchProof\n     * @static\n     * @param {ics23.IBatchProof=} [properties] Properties to set\n     * @returns {ics23.BatchProof} BatchProof instance\n     */\n\n    BatchProof.create = function create(properties) {\n      return new BatchProof(properties);\n    };\n    /**\n     * Encodes the specified BatchProof message. Does not implicitly {@link ics23.BatchProof.verify|verify} messages.\n     * @function encode\n     * @memberof ics23.BatchProof\n     * @static\n     * @param {ics23.IBatchProof} message BatchProof message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    BatchProof.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.entries != null && message.entries.length) for (var i = 0; i < message.entries.length; ++i) $root.ics23.BatchEntry.encode(message.entries[i], writer.uint32(\n      /* id 1, wireType 2 =*/\n      10).fork()).ldelim();\n      return writer;\n    };\n    /**\n     * Encodes the specified BatchProof message, length delimited. Does not implicitly {@link ics23.BatchProof.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ics23.BatchProof\n     * @static\n     * @param {ics23.IBatchProof} message BatchProof message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    BatchProof.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes a BatchProof message from the specified reader or buffer.\n     * @function decode\n     * @memberof ics23.BatchProof\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ics23.BatchProof} BatchProof\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    BatchProof.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.ics23.BatchProof();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            if (!(message.entries && message.entries.length)) message.entries = [];\n            message.entries.push($root.ics23.BatchEntry.decode(reader, reader.uint32()));\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes a BatchProof message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ics23.BatchProof\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ics23.BatchProof} BatchProof\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    BatchProof.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies a BatchProof message.\n     * @function verify\n     * @memberof ics23.BatchProof\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    BatchProof.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n      if (message.entries != null && message.hasOwnProperty(\"entries\")) {\n        if (!Array.isArray(message.entries)) return \"entries: array expected\";\n\n        for (var i = 0; i < message.entries.length; ++i) {\n          var error = $root.ics23.BatchEntry.verify(message.entries[i]);\n          if (error) return \"entries.\" + error;\n        }\n      }\n\n      return null;\n    };\n    /**\n     * Creates a BatchProof message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof ics23.BatchProof\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {ics23.BatchProof} BatchProof\n     */\n\n\n    BatchProof.fromObject = function fromObject(object) {\n      if (object instanceof $root.ics23.BatchProof) return object;\n      var message = new $root.ics23.BatchProof();\n\n      if (object.entries) {\n        if (!Array.isArray(object.entries)) throw TypeError(\".ics23.BatchProof.entries: array expected\");\n        message.entries = [];\n\n        for (var i = 0; i < object.entries.length; ++i) {\n          if (typeof object.entries[i] !== \"object\") throw TypeError(\".ics23.BatchProof.entries: object expected\");\n          message.entries[i] = $root.ics23.BatchEntry.fromObject(object.entries[i]);\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Creates a plain object from a BatchProof message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ics23.BatchProof\n     * @static\n     * @param {ics23.BatchProof} message BatchProof\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    BatchProof.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.arrays || options.defaults) object.entries = [];\n\n      if (message.entries && message.entries.length) {\n        object.entries = [];\n\n        for (var j = 0; j < message.entries.length; ++j) object.entries[j] = $root.ics23.BatchEntry.toObject(message.entries[j], options);\n      }\n\n      return object;\n    };\n    /**\n     * Converts this BatchProof to JSON.\n     * @function toJSON\n     * @memberof ics23.BatchProof\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    BatchProof.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return BatchProof;\n  }();\n\n  ics23.BatchEntry = function () {\n    /**\n     * Properties of a BatchEntry.\n     * @memberof ics23\n     * @interface IBatchEntry\n     * @property {ics23.IExistenceProof|null} [exist] BatchEntry exist\n     * @property {ics23.INonExistenceProof|null} [nonexist] BatchEntry nonexist\n     */\n\n    /**\n     * Constructs a new BatchEntry.\n     * @memberof ics23\n     * @classdesc Represents a BatchEntry.\n     * @implements IBatchEntry\n     * @constructor\n     * @param {ics23.IBatchEntry=} [properties] Properties to set\n     */\n    function BatchEntry(properties) {\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * BatchEntry exist.\n     * @member {ics23.IExistenceProof|null|undefined} exist\n     * @memberof ics23.BatchEntry\n     * @instance\n     */\n\n\n    BatchEntry.prototype.exist = null;\n    /**\n     * BatchEntry nonexist.\n     * @member {ics23.INonExistenceProof|null|undefined} nonexist\n     * @memberof ics23.BatchEntry\n     * @instance\n     */\n\n    BatchEntry.prototype.nonexist = null; // OneOf field names bound to virtual getters and setters\n\n    var $oneOfFields;\n    /**\n     * BatchEntry proof.\n     * @member {\"exist\"|\"nonexist\"|undefined} proof\n     * @memberof ics23.BatchEntry\n     * @instance\n     */\n\n    Object.defineProperty(BatchEntry.prototype, \"proof\", {\n      get: $util.oneOfGetter($oneOfFields = [\"exist\", \"nonexist\"]),\n      set: $util.oneOfSetter($oneOfFields)\n    });\n    /**\n     * Creates a new BatchEntry instance using the specified properties.\n     * @function create\n     * @memberof ics23.BatchEntry\n     * @static\n     * @param {ics23.IBatchEntry=} [properties] Properties to set\n     * @returns {ics23.BatchEntry} BatchEntry instance\n     */\n\n    BatchEntry.create = function create(properties) {\n      return new BatchEntry(properties);\n    };\n    /**\n     * Encodes the specified BatchEntry message. Does not implicitly {@link ics23.BatchEntry.verify|verify} messages.\n     * @function encode\n     * @memberof ics23.BatchEntry\n     * @static\n     * @param {ics23.IBatchEntry} message BatchEntry message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    BatchEntry.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.exist != null && message.hasOwnProperty(\"exist\")) $root.ics23.ExistenceProof.encode(message.exist, writer.uint32(\n      /* id 1, wireType 2 =*/\n      10).fork()).ldelim();\n      if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) $root.ics23.NonExistenceProof.encode(message.nonexist, writer.uint32(\n      /* id 2, wireType 2 =*/\n      18).fork()).ldelim();\n      return writer;\n    };\n    /**\n     * Encodes the specified BatchEntry message, length delimited. Does not implicitly {@link ics23.BatchEntry.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ics23.BatchEntry\n     * @static\n     * @param {ics23.IBatchEntry} message BatchEntry message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    BatchEntry.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes a BatchEntry message from the specified reader or buffer.\n     * @function decode\n     * @memberof ics23.BatchEntry\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ics23.BatchEntry} BatchEntry\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    BatchEntry.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.ics23.BatchEntry();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.exist = $root.ics23.ExistenceProof.decode(reader, reader.uint32());\n            break;\n\n          case 2:\n            message.nonexist = $root.ics23.NonExistenceProof.decode(reader, reader.uint32());\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes a BatchEntry message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ics23.BatchEntry\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ics23.BatchEntry} BatchEntry\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    BatchEntry.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies a BatchEntry message.\n     * @function verify\n     * @memberof ics23.BatchEntry\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    BatchEntry.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n      var properties = {};\n\n      if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n        properties.proof = 1;\n        {\n          var error = $root.ics23.ExistenceProof.verify(message.exist);\n          if (error) return \"exist.\" + error;\n        }\n      }\n\n      if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n        if (properties.proof === 1) return \"proof: multiple values\";\n        properties.proof = 1;\n        {\n          var error = $root.ics23.NonExistenceProof.verify(message.nonexist);\n          if (error) return \"nonexist.\" + error;\n        }\n      }\n\n      return null;\n    };\n    /**\n     * Creates a BatchEntry message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof ics23.BatchEntry\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {ics23.BatchEntry} BatchEntry\n     */\n\n\n    BatchEntry.fromObject = function fromObject(object) {\n      if (object instanceof $root.ics23.BatchEntry) return object;\n      var message = new $root.ics23.BatchEntry();\n\n      if (object.exist != null) {\n        if (typeof object.exist !== \"object\") throw TypeError(\".ics23.BatchEntry.exist: object expected\");\n        message.exist = $root.ics23.ExistenceProof.fromObject(object.exist);\n      }\n\n      if (object.nonexist != null) {\n        if (typeof object.nonexist !== \"object\") throw TypeError(\".ics23.BatchEntry.nonexist: object expected\");\n        message.nonexist = $root.ics23.NonExistenceProof.fromObject(object.nonexist);\n      }\n\n      return message;\n    };\n    /**\n     * Creates a plain object from a BatchEntry message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ics23.BatchEntry\n     * @static\n     * @param {ics23.BatchEntry} message BatchEntry\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    BatchEntry.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n\n      if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n        object.exist = $root.ics23.ExistenceProof.toObject(message.exist, options);\n        if (options.oneofs) object.proof = \"exist\";\n      }\n\n      if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n        object.nonexist = $root.ics23.NonExistenceProof.toObject(message.nonexist, options);\n        if (options.oneofs) object.proof = \"nonexist\";\n      }\n\n      return object;\n    };\n    /**\n     * Converts this BatchEntry to JSON.\n     * @function toJSON\n     * @memberof ics23.BatchEntry\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    BatchEntry.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return BatchEntry;\n  }();\n\n  ics23.CompressedBatchProof = function () {\n    /**\n     * Properties of a CompressedBatchProof.\n     * @memberof ics23\n     * @interface ICompressedBatchProof\n     * @property {Array.<ics23.ICompressedBatchEntry>|null} [entries] CompressedBatchProof entries\n     * @property {Array.<ics23.IInnerOp>|null} [lookupInners] CompressedBatchProof lookupInners\n     */\n\n    /**\n     * Constructs a new CompressedBatchProof.\n     * @memberof ics23\n     * @classdesc Represents a CompressedBatchProof.\n     * @implements ICompressedBatchProof\n     * @constructor\n     * @param {ics23.ICompressedBatchProof=} [properties] Properties to set\n     */\n    function CompressedBatchProof(properties) {\n      this.entries = [];\n      this.lookupInners = [];\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CompressedBatchProof entries.\n     * @member {Array.<ics23.ICompressedBatchEntry>} entries\n     * @memberof ics23.CompressedBatchProof\n     * @instance\n     */\n\n\n    CompressedBatchProof.prototype.entries = $util.emptyArray;\n    /**\n     * CompressedBatchProof lookupInners.\n     * @member {Array.<ics23.IInnerOp>} lookupInners\n     * @memberof ics23.CompressedBatchProof\n     * @instance\n     */\n\n    CompressedBatchProof.prototype.lookupInners = $util.emptyArray;\n    /**\n     * Creates a new CompressedBatchProof instance using the specified properties.\n     * @function create\n     * @memberof ics23.CompressedBatchProof\n     * @static\n     * @param {ics23.ICompressedBatchProof=} [properties] Properties to set\n     * @returns {ics23.CompressedBatchProof} CompressedBatchProof instance\n     */\n\n    CompressedBatchProof.create = function create(properties) {\n      return new CompressedBatchProof(properties);\n    };\n    /**\n     * Encodes the specified CompressedBatchProof message. Does not implicitly {@link ics23.CompressedBatchProof.verify|verify} messages.\n     * @function encode\n     * @memberof ics23.CompressedBatchProof\n     * @static\n     * @param {ics23.ICompressedBatchProof} message CompressedBatchProof message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    CompressedBatchProof.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.entries != null && message.entries.length) for (var i = 0; i < message.entries.length; ++i) $root.ics23.CompressedBatchEntry.encode(message.entries[i], writer.uint32(\n      /* id 1, wireType 2 =*/\n      10).fork()).ldelim();\n      if (message.lookupInners != null && message.lookupInners.length) for (var i = 0; i < message.lookupInners.length; ++i) $root.ics23.InnerOp.encode(message.lookupInners[i], writer.uint32(\n      /* id 2, wireType 2 =*/\n      18).fork()).ldelim();\n      return writer;\n    };\n    /**\n     * Encodes the specified CompressedBatchProof message, length delimited. Does not implicitly {@link ics23.CompressedBatchProof.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ics23.CompressedBatchProof\n     * @static\n     * @param {ics23.ICompressedBatchProof} message CompressedBatchProof message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    CompressedBatchProof.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes a CompressedBatchProof message from the specified reader or buffer.\n     * @function decode\n     * @memberof ics23.CompressedBatchProof\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ics23.CompressedBatchProof} CompressedBatchProof\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    CompressedBatchProof.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.ics23.CompressedBatchProof();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            if (!(message.entries && message.entries.length)) message.entries = [];\n            message.entries.push($root.ics23.CompressedBatchEntry.decode(reader, reader.uint32()));\n            break;\n\n          case 2:\n            if (!(message.lookupInners && message.lookupInners.length)) message.lookupInners = [];\n            message.lookupInners.push($root.ics23.InnerOp.decode(reader, reader.uint32()));\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes a CompressedBatchProof message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ics23.CompressedBatchProof\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ics23.CompressedBatchProof} CompressedBatchProof\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    CompressedBatchProof.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies a CompressedBatchProof message.\n     * @function verify\n     * @memberof ics23.CompressedBatchProof\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    CompressedBatchProof.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n      if (message.entries != null && message.hasOwnProperty(\"entries\")) {\n        if (!Array.isArray(message.entries)) return \"entries: array expected\";\n\n        for (var i = 0; i < message.entries.length; ++i) {\n          var error = $root.ics23.CompressedBatchEntry.verify(message.entries[i]);\n          if (error) return \"entries.\" + error;\n        }\n      }\n\n      if (message.lookupInners != null && message.hasOwnProperty(\"lookupInners\")) {\n        if (!Array.isArray(message.lookupInners)) return \"lookupInners: array expected\";\n\n        for (var i = 0; i < message.lookupInners.length; ++i) {\n          var error = $root.ics23.InnerOp.verify(message.lookupInners[i]);\n          if (error) return \"lookupInners.\" + error;\n        }\n      }\n\n      return null;\n    };\n    /**\n     * Creates a CompressedBatchProof message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof ics23.CompressedBatchProof\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {ics23.CompressedBatchProof} CompressedBatchProof\n     */\n\n\n    CompressedBatchProof.fromObject = function fromObject(object) {\n      if (object instanceof $root.ics23.CompressedBatchProof) return object;\n      var message = new $root.ics23.CompressedBatchProof();\n\n      if (object.entries) {\n        if (!Array.isArray(object.entries)) throw TypeError(\".ics23.CompressedBatchProof.entries: array expected\");\n        message.entries = [];\n\n        for (var i = 0; i < object.entries.length; ++i) {\n          if (typeof object.entries[i] !== \"object\") throw TypeError(\".ics23.CompressedBatchProof.entries: object expected\");\n          message.entries[i] = $root.ics23.CompressedBatchEntry.fromObject(object.entries[i]);\n        }\n      }\n\n      if (object.lookupInners) {\n        if (!Array.isArray(object.lookupInners)) throw TypeError(\".ics23.CompressedBatchProof.lookupInners: array expected\");\n        message.lookupInners = [];\n\n        for (var i = 0; i < object.lookupInners.length; ++i) {\n          if (typeof object.lookupInners[i] !== \"object\") throw TypeError(\".ics23.CompressedBatchProof.lookupInners: object expected\");\n          message.lookupInners[i] = $root.ics23.InnerOp.fromObject(object.lookupInners[i]);\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Creates a plain object from a CompressedBatchProof message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ics23.CompressedBatchProof\n     * @static\n     * @param {ics23.CompressedBatchProof} message CompressedBatchProof\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    CompressedBatchProof.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n\n      if (options.arrays || options.defaults) {\n        object.entries = [];\n        object.lookupInners = [];\n      }\n\n      if (message.entries && message.entries.length) {\n        object.entries = [];\n\n        for (var j = 0; j < message.entries.length; ++j) object.entries[j] = $root.ics23.CompressedBatchEntry.toObject(message.entries[j], options);\n      }\n\n      if (message.lookupInners && message.lookupInners.length) {\n        object.lookupInners = [];\n\n        for (var j = 0; j < message.lookupInners.length; ++j) object.lookupInners[j] = $root.ics23.InnerOp.toObject(message.lookupInners[j], options);\n      }\n\n      return object;\n    };\n    /**\n     * Converts this CompressedBatchProof to JSON.\n     * @function toJSON\n     * @memberof ics23.CompressedBatchProof\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    CompressedBatchProof.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return CompressedBatchProof;\n  }();\n\n  ics23.CompressedBatchEntry = function () {\n    /**\n     * Properties of a CompressedBatchEntry.\n     * @memberof ics23\n     * @interface ICompressedBatchEntry\n     * @property {ics23.ICompressedExistenceProof|null} [exist] CompressedBatchEntry exist\n     * @property {ics23.ICompressedNonExistenceProof|null} [nonexist] CompressedBatchEntry nonexist\n     */\n\n    /**\n     * Constructs a new CompressedBatchEntry.\n     * @memberof ics23\n     * @classdesc Represents a CompressedBatchEntry.\n     * @implements ICompressedBatchEntry\n     * @constructor\n     * @param {ics23.ICompressedBatchEntry=} [properties] Properties to set\n     */\n    function CompressedBatchEntry(properties) {\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CompressedBatchEntry exist.\n     * @member {ics23.ICompressedExistenceProof|null|undefined} exist\n     * @memberof ics23.CompressedBatchEntry\n     * @instance\n     */\n\n\n    CompressedBatchEntry.prototype.exist = null;\n    /**\n     * CompressedBatchEntry nonexist.\n     * @member {ics23.ICompressedNonExistenceProof|null|undefined} nonexist\n     * @memberof ics23.CompressedBatchEntry\n     * @instance\n     */\n\n    CompressedBatchEntry.prototype.nonexist = null; // OneOf field names bound to virtual getters and setters\n\n    var $oneOfFields;\n    /**\n     * CompressedBatchEntry proof.\n     * @member {\"exist\"|\"nonexist\"|undefined} proof\n     * @memberof ics23.CompressedBatchEntry\n     * @instance\n     */\n\n    Object.defineProperty(CompressedBatchEntry.prototype, \"proof\", {\n      get: $util.oneOfGetter($oneOfFields = [\"exist\", \"nonexist\"]),\n      set: $util.oneOfSetter($oneOfFields)\n    });\n    /**\n     * Creates a new CompressedBatchEntry instance using the specified properties.\n     * @function create\n     * @memberof ics23.CompressedBatchEntry\n     * @static\n     * @param {ics23.ICompressedBatchEntry=} [properties] Properties to set\n     * @returns {ics23.CompressedBatchEntry} CompressedBatchEntry instance\n     */\n\n    CompressedBatchEntry.create = function create(properties) {\n      return new CompressedBatchEntry(properties);\n    };\n    /**\n     * Encodes the specified CompressedBatchEntry message. Does not implicitly {@link ics23.CompressedBatchEntry.verify|verify} messages.\n     * @function encode\n     * @memberof ics23.CompressedBatchEntry\n     * @static\n     * @param {ics23.ICompressedBatchEntry} message CompressedBatchEntry message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    CompressedBatchEntry.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.exist != null && message.hasOwnProperty(\"exist\")) $root.ics23.CompressedExistenceProof.encode(message.exist, writer.uint32(\n      /* id 1, wireType 2 =*/\n      10).fork()).ldelim();\n      if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) $root.ics23.CompressedNonExistenceProof.encode(message.nonexist, writer.uint32(\n      /* id 2, wireType 2 =*/\n      18).fork()).ldelim();\n      return writer;\n    };\n    /**\n     * Encodes the specified CompressedBatchEntry message, length delimited. Does not implicitly {@link ics23.CompressedBatchEntry.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ics23.CompressedBatchEntry\n     * @static\n     * @param {ics23.ICompressedBatchEntry} message CompressedBatchEntry message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    CompressedBatchEntry.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes a CompressedBatchEntry message from the specified reader or buffer.\n     * @function decode\n     * @memberof ics23.CompressedBatchEntry\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ics23.CompressedBatchEntry} CompressedBatchEntry\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    CompressedBatchEntry.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.ics23.CompressedBatchEntry();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.exist = $root.ics23.CompressedExistenceProof.decode(reader, reader.uint32());\n            break;\n\n          case 2:\n            message.nonexist = $root.ics23.CompressedNonExistenceProof.decode(reader, reader.uint32());\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes a CompressedBatchEntry message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ics23.CompressedBatchEntry\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ics23.CompressedBatchEntry} CompressedBatchEntry\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    CompressedBatchEntry.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies a CompressedBatchEntry message.\n     * @function verify\n     * @memberof ics23.CompressedBatchEntry\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    CompressedBatchEntry.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n      var properties = {};\n\n      if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n        properties.proof = 1;\n        {\n          var error = $root.ics23.CompressedExistenceProof.verify(message.exist);\n          if (error) return \"exist.\" + error;\n        }\n      }\n\n      if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n        if (properties.proof === 1) return \"proof: multiple values\";\n        properties.proof = 1;\n        {\n          var error = $root.ics23.CompressedNonExistenceProof.verify(message.nonexist);\n          if (error) return \"nonexist.\" + error;\n        }\n      }\n\n      return null;\n    };\n    /**\n     * Creates a CompressedBatchEntry message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof ics23.CompressedBatchEntry\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {ics23.CompressedBatchEntry} CompressedBatchEntry\n     */\n\n\n    CompressedBatchEntry.fromObject = function fromObject(object) {\n      if (object instanceof $root.ics23.CompressedBatchEntry) return object;\n      var message = new $root.ics23.CompressedBatchEntry();\n\n      if (object.exist != null) {\n        if (typeof object.exist !== \"object\") throw TypeError(\".ics23.CompressedBatchEntry.exist: object expected\");\n        message.exist = $root.ics23.CompressedExistenceProof.fromObject(object.exist);\n      }\n\n      if (object.nonexist != null) {\n        if (typeof object.nonexist !== \"object\") throw TypeError(\".ics23.CompressedBatchEntry.nonexist: object expected\");\n        message.nonexist = $root.ics23.CompressedNonExistenceProof.fromObject(object.nonexist);\n      }\n\n      return message;\n    };\n    /**\n     * Creates a plain object from a CompressedBatchEntry message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ics23.CompressedBatchEntry\n     * @static\n     * @param {ics23.CompressedBatchEntry} message CompressedBatchEntry\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    CompressedBatchEntry.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n\n      if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n        object.exist = $root.ics23.CompressedExistenceProof.toObject(message.exist, options);\n        if (options.oneofs) object.proof = \"exist\";\n      }\n\n      if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n        object.nonexist = $root.ics23.CompressedNonExistenceProof.toObject(message.nonexist, options);\n        if (options.oneofs) object.proof = \"nonexist\";\n      }\n\n      return object;\n    };\n    /**\n     * Converts this CompressedBatchEntry to JSON.\n     * @function toJSON\n     * @memberof ics23.CompressedBatchEntry\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    CompressedBatchEntry.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return CompressedBatchEntry;\n  }();\n\n  ics23.CompressedExistenceProof = function () {\n    /**\n     * Properties of a CompressedExistenceProof.\n     * @memberof ics23\n     * @interface ICompressedExistenceProof\n     * @property {Uint8Array|null} [key] CompressedExistenceProof key\n     * @property {Uint8Array|null} [value] CompressedExistenceProof value\n     * @property {ics23.ILeafOp|null} [leaf] CompressedExistenceProof leaf\n     * @property {Array.<number>|null} [path] CompressedExistenceProof path\n     */\n\n    /**\n     * Constructs a new CompressedExistenceProof.\n     * @memberof ics23\n     * @classdesc Represents a CompressedExistenceProof.\n     * @implements ICompressedExistenceProof\n     * @constructor\n     * @param {ics23.ICompressedExistenceProof=} [properties] Properties to set\n     */\n    function CompressedExistenceProof(properties) {\n      this.path = [];\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CompressedExistenceProof key.\n     * @member {Uint8Array} key\n     * @memberof ics23.CompressedExistenceProof\n     * @instance\n     */\n\n\n    CompressedExistenceProof.prototype.key = $util.newBuffer([]);\n    /**\n     * CompressedExistenceProof value.\n     * @member {Uint8Array} value\n     * @memberof ics23.CompressedExistenceProof\n     * @instance\n     */\n\n    CompressedExistenceProof.prototype.value = $util.newBuffer([]);\n    /**\n     * CompressedExistenceProof leaf.\n     * @member {ics23.ILeafOp|null|undefined} leaf\n     * @memberof ics23.CompressedExistenceProof\n     * @instance\n     */\n\n    CompressedExistenceProof.prototype.leaf = null;\n    /**\n     * CompressedExistenceProof path.\n     * @member {Array.<number>} path\n     * @memberof ics23.CompressedExistenceProof\n     * @instance\n     */\n\n    CompressedExistenceProof.prototype.path = $util.emptyArray;\n    /**\n     * Creates a new CompressedExistenceProof instance using the specified properties.\n     * @function create\n     * @memberof ics23.CompressedExistenceProof\n     * @static\n     * @param {ics23.ICompressedExistenceProof=} [properties] Properties to set\n     * @returns {ics23.CompressedExistenceProof} CompressedExistenceProof instance\n     */\n\n    CompressedExistenceProof.create = function create(properties) {\n      return new CompressedExistenceProof(properties);\n    };\n    /**\n     * Encodes the specified CompressedExistenceProof message. Does not implicitly {@link ics23.CompressedExistenceProof.verify|verify} messages.\n     * @function encode\n     * @memberof ics23.CompressedExistenceProof\n     * @static\n     * @param {ics23.ICompressedExistenceProof} message CompressedExistenceProof message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    CompressedExistenceProof.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.key != null && message.hasOwnProperty(\"key\")) writer.uint32(\n      /* id 1, wireType 2 =*/\n      10).bytes(message.key);\n      if (message.value != null && message.hasOwnProperty(\"value\")) writer.uint32(\n      /* id 2, wireType 2 =*/\n      18).bytes(message.value);\n      if (message.leaf != null && message.hasOwnProperty(\"leaf\")) $root.ics23.LeafOp.encode(message.leaf, writer.uint32(\n      /* id 3, wireType 2 =*/\n      26).fork()).ldelim();\n\n      if (message.path != null && message.path.length) {\n        writer.uint32(\n        /* id 4, wireType 2 =*/\n        34).fork();\n\n        for (var i = 0; i < message.path.length; ++i) writer.int32(message.path[i]);\n\n        writer.ldelim();\n      }\n\n      return writer;\n    };\n    /**\n     * Encodes the specified CompressedExistenceProof message, length delimited. Does not implicitly {@link ics23.CompressedExistenceProof.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ics23.CompressedExistenceProof\n     * @static\n     * @param {ics23.ICompressedExistenceProof} message CompressedExistenceProof message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    CompressedExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes a CompressedExistenceProof message from the specified reader or buffer.\n     * @function decode\n     * @memberof ics23.CompressedExistenceProof\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ics23.CompressedExistenceProof} CompressedExistenceProof\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    CompressedExistenceProof.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.ics23.CompressedExistenceProof();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.key = reader.bytes();\n            break;\n\n          case 2:\n            message.value = reader.bytes();\n            break;\n\n          case 3:\n            message.leaf = $root.ics23.LeafOp.decode(reader, reader.uint32());\n            break;\n\n          case 4:\n            if (!(message.path && message.path.length)) message.path = [];\n\n            if ((tag & 7) === 2) {\n              var end2 = reader.uint32() + reader.pos;\n\n              while (reader.pos < end2) message.path.push(reader.int32());\n            } else message.path.push(reader.int32());\n\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes a CompressedExistenceProof message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ics23.CompressedExistenceProof\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ics23.CompressedExistenceProof} CompressedExistenceProof\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    CompressedExistenceProof.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies a CompressedExistenceProof message.\n     * @function verify\n     * @memberof ics23.CompressedExistenceProof\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    CompressedExistenceProof.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n      if (message.key != null && message.hasOwnProperty(\"key\")) if (!(message.key && typeof message.key.length === \"number\" || $util.isString(message.key))) return \"key: buffer expected\";\n      if (message.value != null && message.hasOwnProperty(\"value\")) if (!(message.value && typeof message.value.length === \"number\" || $util.isString(message.value))) return \"value: buffer expected\";\n\n      if (message.leaf != null && message.hasOwnProperty(\"leaf\")) {\n        var error = $root.ics23.LeafOp.verify(message.leaf);\n        if (error) return \"leaf.\" + error;\n      }\n\n      if (message.path != null && message.hasOwnProperty(\"path\")) {\n        if (!Array.isArray(message.path)) return \"path: array expected\";\n\n        for (var i = 0; i < message.path.length; ++i) if (!$util.isInteger(message.path[i])) return \"path: integer[] expected\";\n      }\n\n      return null;\n    };\n    /**\n     * Creates a CompressedExistenceProof message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof ics23.CompressedExistenceProof\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {ics23.CompressedExistenceProof} CompressedExistenceProof\n     */\n\n\n    CompressedExistenceProof.fromObject = function fromObject(object) {\n      if (object instanceof $root.ics23.CompressedExistenceProof) return object;\n      var message = new $root.ics23.CompressedExistenceProof();\n      if (object.key != null) if (typeof object.key === \"string\") $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);else if (object.key.length) message.key = object.key;\n      if (object.value != null) if (typeof object.value === \"string\") $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);else if (object.value.length) message.value = object.value;\n\n      if (object.leaf != null) {\n        if (typeof object.leaf !== \"object\") throw TypeError(\".ics23.CompressedExistenceProof.leaf: object expected\");\n        message.leaf = $root.ics23.LeafOp.fromObject(object.leaf);\n      }\n\n      if (object.path) {\n        if (!Array.isArray(object.path)) throw TypeError(\".ics23.CompressedExistenceProof.path: array expected\");\n        message.path = [];\n\n        for (var i = 0; i < object.path.length; ++i) message.path[i] = object.path[i] | 0;\n      }\n\n      return message;\n    };\n    /**\n     * Creates a plain object from a CompressedExistenceProof message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ics23.CompressedExistenceProof\n     * @static\n     * @param {ics23.CompressedExistenceProof} message CompressedExistenceProof\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    CompressedExistenceProof.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.arrays || options.defaults) object.path = [];\n\n      if (options.defaults) {\n        if (options.bytes === String) object.key = \"\";else {\n          object.key = [];\n          if (options.bytes !== Array) object.key = $util.newBuffer(object.key);\n        }\n        if (options.bytes === String) object.value = \"\";else {\n          object.value = [];\n          if (options.bytes !== Array) object.value = $util.newBuffer(object.value);\n        }\n        object.leaf = null;\n      }\n\n      if (message.key != null && message.hasOwnProperty(\"key\")) object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;\n      if (message.value != null && message.hasOwnProperty(\"value\")) object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;\n      if (message.leaf != null && message.hasOwnProperty(\"leaf\")) object.leaf = $root.ics23.LeafOp.toObject(message.leaf, options);\n\n      if (message.path && message.path.length) {\n        object.path = [];\n\n        for (var j = 0; j < message.path.length; ++j) object.path[j] = message.path[j];\n      }\n\n      return object;\n    };\n    /**\n     * Converts this CompressedExistenceProof to JSON.\n     * @function toJSON\n     * @memberof ics23.CompressedExistenceProof\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    CompressedExistenceProof.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return CompressedExistenceProof;\n  }();\n\n  ics23.CompressedNonExistenceProof = function () {\n    /**\n     * Properties of a CompressedNonExistenceProof.\n     * @memberof ics23\n     * @interface ICompressedNonExistenceProof\n     * @property {Uint8Array|null} [key] CompressedNonExistenceProof key\n     * @property {ics23.ICompressedExistenceProof|null} [left] CompressedNonExistenceProof left\n     * @property {ics23.ICompressedExistenceProof|null} [right] CompressedNonExistenceProof right\n     */\n\n    /**\n     * Constructs a new CompressedNonExistenceProof.\n     * @memberof ics23\n     * @classdesc Represents a CompressedNonExistenceProof.\n     * @implements ICompressedNonExistenceProof\n     * @constructor\n     * @param {ics23.ICompressedNonExistenceProof=} [properties] Properties to set\n     */\n    function CompressedNonExistenceProof(properties) {\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CompressedNonExistenceProof key.\n     * @member {Uint8Array} key\n     * @memberof ics23.CompressedNonExistenceProof\n     * @instance\n     */\n\n\n    CompressedNonExistenceProof.prototype.key = $util.newBuffer([]);\n    /**\n     * CompressedNonExistenceProof left.\n     * @member {ics23.ICompressedExistenceProof|null|undefined} left\n     * @memberof ics23.CompressedNonExistenceProof\n     * @instance\n     */\n\n    CompressedNonExistenceProof.prototype.left = null;\n    /**\n     * CompressedNonExistenceProof right.\n     * @member {ics23.ICompressedExistenceProof|null|undefined} right\n     * @memberof ics23.CompressedNonExistenceProof\n     * @instance\n     */\n\n    CompressedNonExistenceProof.prototype.right = null;\n    /**\n     * Creates a new CompressedNonExistenceProof instance using the specified properties.\n     * @function create\n     * @memberof ics23.CompressedNonExistenceProof\n     * @static\n     * @param {ics23.ICompressedNonExistenceProof=} [properties] Properties to set\n     * @returns {ics23.CompressedNonExistenceProof} CompressedNonExistenceProof instance\n     */\n\n    CompressedNonExistenceProof.create = function create(properties) {\n      return new CompressedNonExistenceProof(properties);\n    };\n    /**\n     * Encodes the specified CompressedNonExistenceProof message. Does not implicitly {@link ics23.CompressedNonExistenceProof.verify|verify} messages.\n     * @function encode\n     * @memberof ics23.CompressedNonExistenceProof\n     * @static\n     * @param {ics23.ICompressedNonExistenceProof} message CompressedNonExistenceProof message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    CompressedNonExistenceProof.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.key != null && message.hasOwnProperty(\"key\")) writer.uint32(\n      /* id 1, wireType 2 =*/\n      10).bytes(message.key);\n      if (message.left != null && message.hasOwnProperty(\"left\")) $root.ics23.CompressedExistenceProof.encode(message.left, writer.uint32(\n      /* id 2, wireType 2 =*/\n      18).fork()).ldelim();\n      if (message.right != null && message.hasOwnProperty(\"right\")) $root.ics23.CompressedExistenceProof.encode(message.right, writer.uint32(\n      /* id 3, wireType 2 =*/\n      26).fork()).ldelim();\n      return writer;\n    };\n    /**\n     * Encodes the specified CompressedNonExistenceProof message, length delimited. Does not implicitly {@link ics23.CompressedNonExistenceProof.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ics23.CompressedNonExistenceProof\n     * @static\n     * @param {ics23.ICompressedNonExistenceProof} message CompressedNonExistenceProof message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    CompressedNonExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes a CompressedNonExistenceProof message from the specified reader or buffer.\n     * @function decode\n     * @memberof ics23.CompressedNonExistenceProof\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ics23.CompressedNonExistenceProof} CompressedNonExistenceProof\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    CompressedNonExistenceProof.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.ics23.CompressedNonExistenceProof();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.key = reader.bytes();\n            break;\n\n          case 2:\n            message.left = $root.ics23.CompressedExistenceProof.decode(reader, reader.uint32());\n            break;\n\n          case 3:\n            message.right = $root.ics23.CompressedExistenceProof.decode(reader, reader.uint32());\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes a CompressedNonExistenceProof message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ics23.CompressedNonExistenceProof\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ics23.CompressedNonExistenceProof} CompressedNonExistenceProof\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    CompressedNonExistenceProof.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies a CompressedNonExistenceProof message.\n     * @function verify\n     * @memberof ics23.CompressedNonExistenceProof\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    CompressedNonExistenceProof.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n      if (message.key != null && message.hasOwnProperty(\"key\")) if (!(message.key && typeof message.key.length === \"number\" || $util.isString(message.key))) return \"key: buffer expected\";\n\n      if (message.left != null && message.hasOwnProperty(\"left\")) {\n        var error = $root.ics23.CompressedExistenceProof.verify(message.left);\n        if (error) return \"left.\" + error;\n      }\n\n      if (message.right != null && message.hasOwnProperty(\"right\")) {\n        var error = $root.ics23.CompressedExistenceProof.verify(message.right);\n        if (error) return \"right.\" + error;\n      }\n\n      return null;\n    };\n    /**\n     * Creates a CompressedNonExistenceProof message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof ics23.CompressedNonExistenceProof\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {ics23.CompressedNonExistenceProof} CompressedNonExistenceProof\n     */\n\n\n    CompressedNonExistenceProof.fromObject = function fromObject(object) {\n      if (object instanceof $root.ics23.CompressedNonExistenceProof) return object;\n      var message = new $root.ics23.CompressedNonExistenceProof();\n      if (object.key != null) if (typeof object.key === \"string\") $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);else if (object.key.length) message.key = object.key;\n\n      if (object.left != null) {\n        if (typeof object.left !== \"object\") throw TypeError(\".ics23.CompressedNonExistenceProof.left: object expected\");\n        message.left = $root.ics23.CompressedExistenceProof.fromObject(object.left);\n      }\n\n      if (object.right != null) {\n        if (typeof object.right !== \"object\") throw TypeError(\".ics23.CompressedNonExistenceProof.right: object expected\");\n        message.right = $root.ics23.CompressedExistenceProof.fromObject(object.right);\n      }\n\n      return message;\n    };\n    /**\n     * Creates a plain object from a CompressedNonExistenceProof message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ics23.CompressedNonExistenceProof\n     * @static\n     * @param {ics23.CompressedNonExistenceProof} message CompressedNonExistenceProof\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    CompressedNonExistenceProof.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n\n      if (options.defaults) {\n        if (options.bytes === String) object.key = \"\";else {\n          object.key = [];\n          if (options.bytes !== Array) object.key = $util.newBuffer(object.key);\n        }\n        object.left = null;\n        object.right = null;\n      }\n\n      if (message.key != null && message.hasOwnProperty(\"key\")) object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;\n      if (message.left != null && message.hasOwnProperty(\"left\")) object.left = $root.ics23.CompressedExistenceProof.toObject(message.left, options);\n      if (message.right != null && message.hasOwnProperty(\"right\")) object.right = $root.ics23.CompressedExistenceProof.toObject(message.right, options);\n      return object;\n    };\n    /**\n     * Converts this CompressedNonExistenceProof to JSON.\n     * @function toJSON\n     * @memberof ics23.CompressedNonExistenceProof\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    CompressedNonExistenceProof.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return CompressedNonExistenceProof;\n  }();\n\n  return ics23;\n}();\n\nmodule.exports = $root;","map":{"version":3,"names":["$protobuf","require","$Reader","Reader","$Writer","Writer","$util","util","$root","roots","ics23","HashOp","valuesById","values","Object","create","LengthOp","ExistenceProof","properties","path","keys","i","length","prototype","key","newBuffer","value","leaf","emptyArray","encode","message","writer","hasOwnProperty","uint32","bytes","LeafOp","fork","ldelim","InnerOp","encodeDelimited","decode","reader","end","undefined","len","pos","tag","push","skipType","decodeDelimited","verify","isString","error","Array","isArray","fromObject","object","base64","TypeError","toObject","options","arrays","defaults","String","slice","call","j","toJSON","constructor","toJSONOptions","NonExistenceProof","left","right","CommitmentProof","exist","nonexist","batch","compressed","$oneOfFields","defineProperty","get","oneOfGetter","set","oneOfSetter","BatchProof","CompressedBatchProof","proof","oneofs","hash","prehashKey","prehashValue","prefix","int32","enums","suffix","ProofSpec","leafSpec","innerSpec","maxDepth","minDepth","InnerSpec","isInteger","childOrder","childSize","minPrefixLength","maxPrefixLength","emptyChild","end2","entries","BatchEntry","lookupInners","CompressedBatchEntry","CompressedExistenceProof","CompressedNonExistenceProof","module","exports"],"sources":["/Users/bernapolat/blockchainbingoballs/node_modules/@confio/ics23/build/generated/codecimpl.js"],"sourcesContent":["/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n\"use strict\";\n\nvar $protobuf = require(\"protobufjs/minimal\");\n\n// Common aliases\nvar $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n\n// Exported root namespace\nvar $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n\n$root.ics23 = (function() {\n\n    /**\n     * Namespace ics23.\n     * @exports ics23\n     * @namespace\n     */\n    var ics23 = {};\n\n    /**\n     * HashOp enum.\n     * @name ics23.HashOp\n     * @enum {string}\n     * @property {number} NO_HASH=0 NO_HASH value\n     * @property {number} SHA256=1 SHA256 value\n     * @property {number} SHA512=2 SHA512 value\n     * @property {number} KECCAK=3 KECCAK value\n     * @property {number} RIPEMD160=4 RIPEMD160 value\n     * @property {number} BITCOIN=5 BITCOIN value\n     * @property {number} SHA512_256=6 SHA512_256 value\n     */\n    ics23.HashOp = (function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"NO_HASH\"] = 0;\n        values[valuesById[1] = \"SHA256\"] = 1;\n        values[valuesById[2] = \"SHA512\"] = 2;\n        values[valuesById[3] = \"KECCAK\"] = 3;\n        values[valuesById[4] = \"RIPEMD160\"] = 4;\n        values[valuesById[5] = \"BITCOIN\"] = 5;\n        values[valuesById[6] = \"SHA512_256\"] = 6;\n        return values;\n    })();\n\n    /**\n     * LengthOp defines how to process the key and value of the LeafOp\n     * to include length information. After encoding the length with the given\n     * algorithm, the length will be prepended to the key and value bytes.\n     * (Each one with it's own encoded length)\n     * @name ics23.LengthOp\n     * @enum {string}\n     * @property {number} NO_PREFIX=0 NO_PREFIX value\n     * @property {number} VAR_PROTO=1 VAR_PROTO value\n     * @property {number} VAR_RLP=2 VAR_RLP value\n     * @property {number} FIXED32_BIG=3 FIXED32_BIG value\n     * @property {number} FIXED32_LITTLE=4 FIXED32_LITTLE value\n     * @property {number} FIXED64_BIG=5 FIXED64_BIG value\n     * @property {number} FIXED64_LITTLE=6 FIXED64_LITTLE value\n     * @property {number} REQUIRE_32_BYTES=7 REQUIRE_32_BYTES value\n     * @property {number} REQUIRE_64_BYTES=8 REQUIRE_64_BYTES value\n     */\n    ics23.LengthOp = (function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"NO_PREFIX\"] = 0;\n        values[valuesById[1] = \"VAR_PROTO\"] = 1;\n        values[valuesById[2] = \"VAR_RLP\"] = 2;\n        values[valuesById[3] = \"FIXED32_BIG\"] = 3;\n        values[valuesById[4] = \"FIXED32_LITTLE\"] = 4;\n        values[valuesById[5] = \"FIXED64_BIG\"] = 5;\n        values[valuesById[6] = \"FIXED64_LITTLE\"] = 6;\n        values[valuesById[7] = \"REQUIRE_32_BYTES\"] = 7;\n        values[valuesById[8] = \"REQUIRE_64_BYTES\"] = 8;\n        return values;\n    })();\n\n    ics23.ExistenceProof = (function() {\n\n        /**\n         * Properties of an ExistenceProof.\n         * @memberof ics23\n         * @interface IExistenceProof\n         * @property {Uint8Array|null} [key] ExistenceProof key\n         * @property {Uint8Array|null} [value] ExistenceProof value\n         * @property {ics23.ILeafOp|null} [leaf] ExistenceProof leaf\n         * @property {Array.<ics23.IInnerOp>|null} [path] ExistenceProof path\n         */\n\n        /**\n         * Constructs a new ExistenceProof.\n         * @memberof ics23\n         * @classdesc ExistenceProof takes a key and a value and a set of steps to perform on it.\n         * The result of peforming all these steps will provide a \"root hash\", which can\n         * be compared to the value in a header.\n         * \n         * Since it is computationally infeasible to produce a hash collission for any of the used\n         * cryptographic hash functions, if someone can provide a series of operations to transform\n         * a given key and value into a root hash that matches some trusted root, these key and values\n         * must be in the referenced merkle tree.\n         * \n         * The only possible issue is maliablity in LeafOp, such as providing extra prefix data,\n         * which should be controlled by a spec. Eg. with lengthOp as NONE,\n         * prefix = FOO, key = BAR, value = CHOICE\n         * and\n         * prefix = F, key = OOBAR, value = CHOICE\n         * would produce the same value.\n         * \n         * With LengthOp this is tricker but not impossible. Which is why the \"leafPrefixEqual\" field\n         * in the ProofSpec is valuable to prevent this mutability. And why all trees should\n         * length-prefix the data before hashing it.\n         * @implements IExistenceProof\n         * @constructor\n         * @param {ics23.IExistenceProof=} [properties] Properties to set\n         */\n        function ExistenceProof(properties) {\n            this.path = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * ExistenceProof key.\n         * @member {Uint8Array} key\n         * @memberof ics23.ExistenceProof\n         * @instance\n         */\n        ExistenceProof.prototype.key = $util.newBuffer([]);\n\n        /**\n         * ExistenceProof value.\n         * @member {Uint8Array} value\n         * @memberof ics23.ExistenceProof\n         * @instance\n         */\n        ExistenceProof.prototype.value = $util.newBuffer([]);\n\n        /**\n         * ExistenceProof leaf.\n         * @member {ics23.ILeafOp|null|undefined} leaf\n         * @memberof ics23.ExistenceProof\n         * @instance\n         */\n        ExistenceProof.prototype.leaf = null;\n\n        /**\n         * ExistenceProof path.\n         * @member {Array.<ics23.IInnerOp>} path\n         * @memberof ics23.ExistenceProof\n         * @instance\n         */\n        ExistenceProof.prototype.path = $util.emptyArray;\n\n        /**\n         * Creates a new ExistenceProof instance using the specified properties.\n         * @function create\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {ics23.IExistenceProof=} [properties] Properties to set\n         * @returns {ics23.ExistenceProof} ExistenceProof instance\n         */\n        ExistenceProof.create = function create(properties) {\n            return new ExistenceProof(properties);\n        };\n\n        /**\n         * Encodes the specified ExistenceProof message. Does not implicitly {@link ics23.ExistenceProof.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {ics23.IExistenceProof} message ExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ExistenceProof.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);\n            if (message.value != null && message.hasOwnProperty(\"value\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);\n            if (message.leaf != null && message.hasOwnProperty(\"leaf\"))\n                $root.ics23.LeafOp.encode(message.leaf, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n            if (message.path != null && message.path.length)\n                for (var i = 0; i < message.path.length; ++i)\n                    $root.ics23.InnerOp.encode(message.path[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified ExistenceProof message, length delimited. Does not implicitly {@link ics23.ExistenceProof.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {ics23.IExistenceProof} message ExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes an ExistenceProof message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.ExistenceProof} ExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ExistenceProof.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.ExistenceProof();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.bytes();\n                    break;\n                case 2:\n                    message.value = reader.bytes();\n                    break;\n                case 3:\n                    message.leaf = $root.ics23.LeafOp.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    if (!(message.path && message.path.length))\n                        message.path = [];\n                    message.path.push($root.ics23.InnerOp.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes an ExistenceProof message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.ExistenceProof} ExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ExistenceProof.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies an ExistenceProof message.\n         * @function verify\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        ExistenceProof.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                if (!(message.key && typeof message.key.length === \"number\" || $util.isString(message.key)))\n                    return \"key: buffer expected\";\n            if (message.value != null && message.hasOwnProperty(\"value\"))\n                if (!(message.value && typeof message.value.length === \"number\" || $util.isString(message.value)))\n                    return \"value: buffer expected\";\n            if (message.leaf != null && message.hasOwnProperty(\"leaf\")) {\n                var error = $root.ics23.LeafOp.verify(message.leaf);\n                if (error)\n                    return \"leaf.\" + error;\n            }\n            if (message.path != null && message.hasOwnProperty(\"path\")) {\n                if (!Array.isArray(message.path))\n                    return \"path: array expected\";\n                for (var i = 0; i < message.path.length; ++i) {\n                    var error = $root.ics23.InnerOp.verify(message.path[i]);\n                    if (error)\n                        return \"path.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates an ExistenceProof message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.ExistenceProof} ExistenceProof\n         */\n        ExistenceProof.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.ExistenceProof)\n                return object;\n            var message = new $root.ics23.ExistenceProof();\n            if (object.key != null)\n                if (typeof object.key === \"string\")\n                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);\n                else if (object.key.length)\n                    message.key = object.key;\n            if (object.value != null)\n                if (typeof object.value === \"string\")\n                    $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);\n                else if (object.value.length)\n                    message.value = object.value;\n            if (object.leaf != null) {\n                if (typeof object.leaf !== \"object\")\n                    throw TypeError(\".ics23.ExistenceProof.leaf: object expected\");\n                message.leaf = $root.ics23.LeafOp.fromObject(object.leaf);\n            }\n            if (object.path) {\n                if (!Array.isArray(object.path))\n                    throw TypeError(\".ics23.ExistenceProof.path: array expected\");\n                message.path = [];\n                for (var i = 0; i < object.path.length; ++i) {\n                    if (typeof object.path[i] !== \"object\")\n                        throw TypeError(\".ics23.ExistenceProof.path: object expected\");\n                    message.path[i] = $root.ics23.InnerOp.fromObject(object.path[i]);\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from an ExistenceProof message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {ics23.ExistenceProof} message ExistenceProof\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        ExistenceProof.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults)\n                object.path = [];\n            if (options.defaults) {\n                if (options.bytes === String)\n                    object.key = \"\";\n                else {\n                    object.key = [];\n                    if (options.bytes !== Array)\n                        object.key = $util.newBuffer(object.key);\n                }\n                if (options.bytes === String)\n                    object.value = \"\";\n                else {\n                    object.value = [];\n                    if (options.bytes !== Array)\n                        object.value = $util.newBuffer(object.value);\n                }\n                object.leaf = null;\n            }\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;\n            if (message.value != null && message.hasOwnProperty(\"value\"))\n                object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;\n            if (message.leaf != null && message.hasOwnProperty(\"leaf\"))\n                object.leaf = $root.ics23.LeafOp.toObject(message.leaf, options);\n            if (message.path && message.path.length) {\n                object.path = [];\n                for (var j = 0; j < message.path.length; ++j)\n                    object.path[j] = $root.ics23.InnerOp.toObject(message.path[j], options);\n            }\n            return object;\n        };\n\n        /**\n         * Converts this ExistenceProof to JSON.\n         * @function toJSON\n         * @memberof ics23.ExistenceProof\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        ExistenceProof.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return ExistenceProof;\n    })();\n\n    ics23.NonExistenceProof = (function() {\n\n        /**\n         * Properties of a NonExistenceProof.\n         * @memberof ics23\n         * @interface INonExistenceProof\n         * @property {Uint8Array|null} [key] NonExistenceProof key\n         * @property {ics23.IExistenceProof|null} [left] NonExistenceProof left\n         * @property {ics23.IExistenceProof|null} [right] NonExistenceProof right\n         */\n\n        /**\n         * Constructs a new NonExistenceProof.\n         * @memberof ics23\n         * @classdesc Represents a NonExistenceProof.\n         * @implements INonExistenceProof\n         * @constructor\n         * @param {ics23.INonExistenceProof=} [properties] Properties to set\n         */\n        function NonExistenceProof(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * NonExistenceProof key.\n         * @member {Uint8Array} key\n         * @memberof ics23.NonExistenceProof\n         * @instance\n         */\n        NonExistenceProof.prototype.key = $util.newBuffer([]);\n\n        /**\n         * NonExistenceProof left.\n         * @member {ics23.IExistenceProof|null|undefined} left\n         * @memberof ics23.NonExistenceProof\n         * @instance\n         */\n        NonExistenceProof.prototype.left = null;\n\n        /**\n         * NonExistenceProof right.\n         * @member {ics23.IExistenceProof|null|undefined} right\n         * @memberof ics23.NonExistenceProof\n         * @instance\n         */\n        NonExistenceProof.prototype.right = null;\n\n        /**\n         * Creates a new NonExistenceProof instance using the specified properties.\n         * @function create\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {ics23.INonExistenceProof=} [properties] Properties to set\n         * @returns {ics23.NonExistenceProof} NonExistenceProof instance\n         */\n        NonExistenceProof.create = function create(properties) {\n            return new NonExistenceProof(properties);\n        };\n\n        /**\n         * Encodes the specified NonExistenceProof message. Does not implicitly {@link ics23.NonExistenceProof.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {ics23.INonExistenceProof} message NonExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        NonExistenceProof.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);\n            if (message.left != null && message.hasOwnProperty(\"left\"))\n                $root.ics23.ExistenceProof.encode(message.left, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            if (message.right != null && message.hasOwnProperty(\"right\"))\n                $root.ics23.ExistenceProof.encode(message.right, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified NonExistenceProof message, length delimited. Does not implicitly {@link ics23.NonExistenceProof.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {ics23.INonExistenceProof} message NonExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        NonExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a NonExistenceProof message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.NonExistenceProof} NonExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        NonExistenceProof.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.NonExistenceProof();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.bytes();\n                    break;\n                case 2:\n                    message.left = $root.ics23.ExistenceProof.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.right = $root.ics23.ExistenceProof.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a NonExistenceProof message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.NonExistenceProof} NonExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        NonExistenceProof.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a NonExistenceProof message.\n         * @function verify\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        NonExistenceProof.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                if (!(message.key && typeof message.key.length === \"number\" || $util.isString(message.key)))\n                    return \"key: buffer expected\";\n            if (message.left != null && message.hasOwnProperty(\"left\")) {\n                var error = $root.ics23.ExistenceProof.verify(message.left);\n                if (error)\n                    return \"left.\" + error;\n            }\n            if (message.right != null && message.hasOwnProperty(\"right\")) {\n                var error = $root.ics23.ExistenceProof.verify(message.right);\n                if (error)\n                    return \"right.\" + error;\n            }\n            return null;\n        };\n\n        /**\n         * Creates a NonExistenceProof message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.NonExistenceProof} NonExistenceProof\n         */\n        NonExistenceProof.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.NonExistenceProof)\n                return object;\n            var message = new $root.ics23.NonExistenceProof();\n            if (object.key != null)\n                if (typeof object.key === \"string\")\n                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);\n                else if (object.key.length)\n                    message.key = object.key;\n            if (object.left != null) {\n                if (typeof object.left !== \"object\")\n                    throw TypeError(\".ics23.NonExistenceProof.left: object expected\");\n                message.left = $root.ics23.ExistenceProof.fromObject(object.left);\n            }\n            if (object.right != null) {\n                if (typeof object.right !== \"object\")\n                    throw TypeError(\".ics23.NonExistenceProof.right: object expected\");\n                message.right = $root.ics23.ExistenceProof.fromObject(object.right);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a NonExistenceProof message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {ics23.NonExistenceProof} message NonExistenceProof\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        NonExistenceProof.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                if (options.bytes === String)\n                    object.key = \"\";\n                else {\n                    object.key = [];\n                    if (options.bytes !== Array)\n                        object.key = $util.newBuffer(object.key);\n                }\n                object.left = null;\n                object.right = null;\n            }\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;\n            if (message.left != null && message.hasOwnProperty(\"left\"))\n                object.left = $root.ics23.ExistenceProof.toObject(message.left, options);\n            if (message.right != null && message.hasOwnProperty(\"right\"))\n                object.right = $root.ics23.ExistenceProof.toObject(message.right, options);\n            return object;\n        };\n\n        /**\n         * Converts this NonExistenceProof to JSON.\n         * @function toJSON\n         * @memberof ics23.NonExistenceProof\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        NonExistenceProof.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return NonExistenceProof;\n    })();\n\n    ics23.CommitmentProof = (function() {\n\n        /**\n         * Properties of a CommitmentProof.\n         * @memberof ics23\n         * @interface ICommitmentProof\n         * @property {ics23.IExistenceProof|null} [exist] CommitmentProof exist\n         * @property {ics23.INonExistenceProof|null} [nonexist] CommitmentProof nonexist\n         * @property {ics23.IBatchProof|null} [batch] CommitmentProof batch\n         * @property {ics23.ICompressedBatchProof|null} [compressed] CommitmentProof compressed\n         */\n\n        /**\n         * Constructs a new CommitmentProof.\n         * @memberof ics23\n         * @classdesc Represents a CommitmentProof.\n         * @implements ICommitmentProof\n         * @constructor\n         * @param {ics23.ICommitmentProof=} [properties] Properties to set\n         */\n        function CommitmentProof(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * CommitmentProof exist.\n         * @member {ics23.IExistenceProof|null|undefined} exist\n         * @memberof ics23.CommitmentProof\n         * @instance\n         */\n        CommitmentProof.prototype.exist = null;\n\n        /**\n         * CommitmentProof nonexist.\n         * @member {ics23.INonExistenceProof|null|undefined} nonexist\n         * @memberof ics23.CommitmentProof\n         * @instance\n         */\n        CommitmentProof.prototype.nonexist = null;\n\n        /**\n         * CommitmentProof batch.\n         * @member {ics23.IBatchProof|null|undefined} batch\n         * @memberof ics23.CommitmentProof\n         * @instance\n         */\n        CommitmentProof.prototype.batch = null;\n\n        /**\n         * CommitmentProof compressed.\n         * @member {ics23.ICompressedBatchProof|null|undefined} compressed\n         * @memberof ics23.CommitmentProof\n         * @instance\n         */\n        CommitmentProof.prototype.compressed = null;\n\n        // OneOf field names bound to virtual getters and setters\n        var $oneOfFields;\n\n        /**\n         * CommitmentProof proof.\n         * @member {\"exist\"|\"nonexist\"|\"batch\"|\"compressed\"|undefined} proof\n         * @memberof ics23.CommitmentProof\n         * @instance\n         */\n        Object.defineProperty(CommitmentProof.prototype, \"proof\", {\n            get: $util.oneOfGetter($oneOfFields = [\"exist\", \"nonexist\", \"batch\", \"compressed\"]),\n            set: $util.oneOfSetter($oneOfFields)\n        });\n\n        /**\n         * Creates a new CommitmentProof instance using the specified properties.\n         * @function create\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {ics23.ICommitmentProof=} [properties] Properties to set\n         * @returns {ics23.CommitmentProof} CommitmentProof instance\n         */\n        CommitmentProof.create = function create(properties) {\n            return new CommitmentProof(properties);\n        };\n\n        /**\n         * Encodes the specified CommitmentProof message. Does not implicitly {@link ics23.CommitmentProof.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {ics23.ICommitmentProof} message CommitmentProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CommitmentProof.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.exist != null && message.hasOwnProperty(\"exist\"))\n                $root.ics23.ExistenceProof.encode(message.exist, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\"))\n                $root.ics23.NonExistenceProof.encode(message.nonexist, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            if (message.batch != null && message.hasOwnProperty(\"batch\"))\n                $root.ics23.BatchProof.encode(message.batch, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n            if (message.compressed != null && message.hasOwnProperty(\"compressed\"))\n                $root.ics23.CompressedBatchProof.encode(message.compressed, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified CommitmentProof message, length delimited. Does not implicitly {@link ics23.CommitmentProof.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {ics23.ICommitmentProof} message CommitmentProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CommitmentProof.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a CommitmentProof message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.CommitmentProof} CommitmentProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CommitmentProof.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.CommitmentProof();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.exist = $root.ics23.ExistenceProof.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.nonexist = $root.ics23.NonExistenceProof.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.batch = $root.ics23.BatchProof.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.compressed = $root.ics23.CompressedBatchProof.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a CommitmentProof message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.CommitmentProof} CommitmentProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CommitmentProof.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a CommitmentProof message.\n         * @function verify\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        CommitmentProof.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            var properties = {};\n            if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.ExistenceProof.verify(message.exist);\n                    if (error)\n                        return \"exist.\" + error;\n                }\n            }\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n                if (properties.proof === 1)\n                    return \"proof: multiple values\";\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.NonExistenceProof.verify(message.nonexist);\n                    if (error)\n                        return \"nonexist.\" + error;\n                }\n            }\n            if (message.batch != null && message.hasOwnProperty(\"batch\")) {\n                if (properties.proof === 1)\n                    return \"proof: multiple values\";\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.BatchProof.verify(message.batch);\n                    if (error)\n                        return \"batch.\" + error;\n                }\n            }\n            if (message.compressed != null && message.hasOwnProperty(\"compressed\")) {\n                if (properties.proof === 1)\n                    return \"proof: multiple values\";\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.CompressedBatchProof.verify(message.compressed);\n                    if (error)\n                        return \"compressed.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a CommitmentProof message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.CommitmentProof} CommitmentProof\n         */\n        CommitmentProof.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.CommitmentProof)\n                return object;\n            var message = new $root.ics23.CommitmentProof();\n            if (object.exist != null) {\n                if (typeof object.exist !== \"object\")\n                    throw TypeError(\".ics23.CommitmentProof.exist: object expected\");\n                message.exist = $root.ics23.ExistenceProof.fromObject(object.exist);\n            }\n            if (object.nonexist != null) {\n                if (typeof object.nonexist !== \"object\")\n                    throw TypeError(\".ics23.CommitmentProof.nonexist: object expected\");\n                message.nonexist = $root.ics23.NonExistenceProof.fromObject(object.nonexist);\n            }\n            if (object.batch != null) {\n                if (typeof object.batch !== \"object\")\n                    throw TypeError(\".ics23.CommitmentProof.batch: object expected\");\n                message.batch = $root.ics23.BatchProof.fromObject(object.batch);\n            }\n            if (object.compressed != null) {\n                if (typeof object.compressed !== \"object\")\n                    throw TypeError(\".ics23.CommitmentProof.compressed: object expected\");\n                message.compressed = $root.ics23.CompressedBatchProof.fromObject(object.compressed);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a CommitmentProof message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {ics23.CommitmentProof} message CommitmentProof\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        CommitmentProof.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n                object.exist = $root.ics23.ExistenceProof.toObject(message.exist, options);\n                if (options.oneofs)\n                    object.proof = \"exist\";\n            }\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n                object.nonexist = $root.ics23.NonExistenceProof.toObject(message.nonexist, options);\n                if (options.oneofs)\n                    object.proof = \"nonexist\";\n            }\n            if (message.batch != null && message.hasOwnProperty(\"batch\")) {\n                object.batch = $root.ics23.BatchProof.toObject(message.batch, options);\n                if (options.oneofs)\n                    object.proof = \"batch\";\n            }\n            if (message.compressed != null && message.hasOwnProperty(\"compressed\")) {\n                object.compressed = $root.ics23.CompressedBatchProof.toObject(message.compressed, options);\n                if (options.oneofs)\n                    object.proof = \"compressed\";\n            }\n            return object;\n        };\n\n        /**\n         * Converts this CommitmentProof to JSON.\n         * @function toJSON\n         * @memberof ics23.CommitmentProof\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        CommitmentProof.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return CommitmentProof;\n    })();\n\n    ics23.LeafOp = (function() {\n\n        /**\n         * Properties of a LeafOp.\n         * @memberof ics23\n         * @interface ILeafOp\n         * @property {ics23.HashOp|null} [hash] LeafOp hash\n         * @property {ics23.HashOp|null} [prehashKey] LeafOp prehashKey\n         * @property {ics23.HashOp|null} [prehashValue] LeafOp prehashValue\n         * @property {ics23.LengthOp|null} [length] LeafOp length\n         * @property {Uint8Array|null} [prefix] LeafOp prefix\n         */\n\n        /**\n         * Constructs a new LeafOp.\n         * @memberof ics23\n         * @classdesc LeafOp represents the raw key-value data we wish to prove, and\n         * must be flexible to represent the internal transformation from\n         * the original key-value pairs into the basis hash, for many existing\n         * merkle trees.\n         * \n         * key and value are passed in. So that the signature of this operation is:\n         * leafOp(key, value) -> output\n         * \n         * To process this, first prehash the keys and values if needed (ANY means no hash in this case):\n         * hkey = prehashKey(key)\n         * hvalue = prehashValue(value)\n         * \n         * Then combine the bytes, and hash it\n         * output = hash(prefix || length(hkey) || hkey || length(hvalue) || hvalue)\n         * @implements ILeafOp\n         * @constructor\n         * @param {ics23.ILeafOp=} [properties] Properties to set\n         */\n        function LeafOp(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * LeafOp hash.\n         * @member {ics23.HashOp} hash\n         * @memberof ics23.LeafOp\n         * @instance\n         */\n        LeafOp.prototype.hash = 0;\n\n        /**\n         * LeafOp prehashKey.\n         * @member {ics23.HashOp} prehashKey\n         * @memberof ics23.LeafOp\n         * @instance\n         */\n        LeafOp.prototype.prehashKey = 0;\n\n        /**\n         * LeafOp prehashValue.\n         * @member {ics23.HashOp} prehashValue\n         * @memberof ics23.LeafOp\n         * @instance\n         */\n        LeafOp.prototype.prehashValue = 0;\n\n        /**\n         * LeafOp length.\n         * @member {ics23.LengthOp} length\n         * @memberof ics23.LeafOp\n         * @instance\n         */\n        LeafOp.prototype.length = 0;\n\n        /**\n         * LeafOp prefix.\n         * @member {Uint8Array} prefix\n         * @memberof ics23.LeafOp\n         * @instance\n         */\n        LeafOp.prototype.prefix = $util.newBuffer([]);\n\n        /**\n         * Creates a new LeafOp instance using the specified properties.\n         * @function create\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {ics23.ILeafOp=} [properties] Properties to set\n         * @returns {ics23.LeafOp} LeafOp instance\n         */\n        LeafOp.create = function create(properties) {\n            return new LeafOp(properties);\n        };\n\n        /**\n         * Encodes the specified LeafOp message. Does not implicitly {@link ics23.LeafOp.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {ics23.ILeafOp} message LeafOp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        LeafOp.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.hash);\n            if (message.prehashKey != null && message.hasOwnProperty(\"prehashKey\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.prehashKey);\n            if (message.prehashValue != null && message.hasOwnProperty(\"prehashValue\"))\n                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.prehashValue);\n            if (message.length != null && message.hasOwnProperty(\"length\"))\n                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.length);\n            if (message.prefix != null && message.hasOwnProperty(\"prefix\"))\n                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.prefix);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified LeafOp message, length delimited. Does not implicitly {@link ics23.LeafOp.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {ics23.ILeafOp} message LeafOp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        LeafOp.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a LeafOp message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.LeafOp} LeafOp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        LeafOp.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.LeafOp();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.hash = reader.int32();\n                    break;\n                case 2:\n                    message.prehashKey = reader.int32();\n                    break;\n                case 3:\n                    message.prehashValue = reader.int32();\n                    break;\n                case 4:\n                    message.length = reader.int32();\n                    break;\n                case 5:\n                    message.prefix = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a LeafOp message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.LeafOp} LeafOp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        LeafOp.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a LeafOp message.\n         * @function verify\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        LeafOp.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                switch (message.hash) {\n                default:\n                    return \"hash: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 6:\n                    break;\n                }\n            if (message.prehashKey != null && message.hasOwnProperty(\"prehashKey\"))\n                switch (message.prehashKey) {\n                default:\n                    return \"prehashKey: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 6:\n                    break;\n                }\n            if (message.prehashValue != null && message.hasOwnProperty(\"prehashValue\"))\n                switch (message.prehashValue) {\n                default:\n                    return \"prehashValue: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 6:\n                    break;\n                }\n            if (message.length != null && message.hasOwnProperty(\"length\"))\n                switch (message.length) {\n                default:\n                    return \"length: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 6:\n                case 7:\n                case 8:\n                    break;\n                }\n            if (message.prefix != null && message.hasOwnProperty(\"prefix\"))\n                if (!(message.prefix && typeof message.prefix.length === \"number\" || $util.isString(message.prefix)))\n                    return \"prefix: buffer expected\";\n            return null;\n        };\n\n        /**\n         * Creates a LeafOp message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.LeafOp} LeafOp\n         */\n        LeafOp.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.LeafOp)\n                return object;\n            var message = new $root.ics23.LeafOp();\n            switch (object.hash) {\n            case \"NO_HASH\":\n            case 0:\n                message.hash = 0;\n                break;\n            case \"SHA256\":\n            case 1:\n                message.hash = 1;\n                break;\n            case \"SHA512\":\n            case 2:\n                message.hash = 2;\n                break;\n            case \"KECCAK\":\n            case 3:\n                message.hash = 3;\n                break;\n            case \"RIPEMD160\":\n            case 4:\n                message.hash = 4;\n                break;\n            case \"BITCOIN\":\n            case 5:\n                message.hash = 5;\n                break;\n            case \"SHA512_256\":\n            case 6:\n                message.hash = 6;\n                break;\n            }\n            switch (object.prehashKey) {\n            case \"NO_HASH\":\n            case 0:\n                message.prehashKey = 0;\n                break;\n            case \"SHA256\":\n            case 1:\n                message.prehashKey = 1;\n                break;\n            case \"SHA512\":\n            case 2:\n                message.prehashKey = 2;\n                break;\n            case \"KECCAK\":\n            case 3:\n                message.prehashKey = 3;\n                break;\n            case \"RIPEMD160\":\n            case 4:\n                message.prehashKey = 4;\n                break;\n            case \"BITCOIN\":\n            case 5:\n                message.prehashKey = 5;\n                break;\n            case \"SHA512_256\":\n            case 6:\n                message.prehashKey = 6;\n                break;\n            }\n            switch (object.prehashValue) {\n            case \"NO_HASH\":\n            case 0:\n                message.prehashValue = 0;\n                break;\n            case \"SHA256\":\n            case 1:\n                message.prehashValue = 1;\n                break;\n            case \"SHA512\":\n            case 2:\n                message.prehashValue = 2;\n                break;\n            case \"KECCAK\":\n            case 3:\n                message.prehashValue = 3;\n                break;\n            case \"RIPEMD160\":\n            case 4:\n                message.prehashValue = 4;\n                break;\n            case \"BITCOIN\":\n            case 5:\n                message.prehashValue = 5;\n                break;\n            case \"SHA512_256\":\n            case 6:\n                message.prehashValue = 6;\n                break;\n            }\n            switch (object.length) {\n            case \"NO_PREFIX\":\n            case 0:\n                message.length = 0;\n                break;\n            case \"VAR_PROTO\":\n            case 1:\n                message.length = 1;\n                break;\n            case \"VAR_RLP\":\n            case 2:\n                message.length = 2;\n                break;\n            case \"FIXED32_BIG\":\n            case 3:\n                message.length = 3;\n                break;\n            case \"FIXED32_LITTLE\":\n            case 4:\n                message.length = 4;\n                break;\n            case \"FIXED64_BIG\":\n            case 5:\n                message.length = 5;\n                break;\n            case \"FIXED64_LITTLE\":\n            case 6:\n                message.length = 6;\n                break;\n            case \"REQUIRE_32_BYTES\":\n            case 7:\n                message.length = 7;\n                break;\n            case \"REQUIRE_64_BYTES\":\n            case 8:\n                message.length = 8;\n                break;\n            }\n            if (object.prefix != null)\n                if (typeof object.prefix === \"string\")\n                    $util.base64.decode(object.prefix, message.prefix = $util.newBuffer($util.base64.length(object.prefix)), 0);\n                else if (object.prefix.length)\n                    message.prefix = object.prefix;\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a LeafOp message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {ics23.LeafOp} message LeafOp\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        LeafOp.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.hash = options.enums === String ? \"NO_HASH\" : 0;\n                object.prehashKey = options.enums === String ? \"NO_HASH\" : 0;\n                object.prehashValue = options.enums === String ? \"NO_HASH\" : 0;\n                object.length = options.enums === String ? \"NO_PREFIX\" : 0;\n                if (options.bytes === String)\n                    object.prefix = \"\";\n                else {\n                    object.prefix = [];\n                    if (options.bytes !== Array)\n                        object.prefix = $util.newBuffer(object.prefix);\n                }\n            }\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                object.hash = options.enums === String ? $root.ics23.HashOp[message.hash] : message.hash;\n            if (message.prehashKey != null && message.hasOwnProperty(\"prehashKey\"))\n                object.prehashKey = options.enums === String ? $root.ics23.HashOp[message.prehashKey] : message.prehashKey;\n            if (message.prehashValue != null && message.hasOwnProperty(\"prehashValue\"))\n                object.prehashValue = options.enums === String ? $root.ics23.HashOp[message.prehashValue] : message.prehashValue;\n            if (message.length != null && message.hasOwnProperty(\"length\"))\n                object.length = options.enums === String ? $root.ics23.LengthOp[message.length] : message.length;\n            if (message.prefix != null && message.hasOwnProperty(\"prefix\"))\n                object.prefix = options.bytes === String ? $util.base64.encode(message.prefix, 0, message.prefix.length) : options.bytes === Array ? Array.prototype.slice.call(message.prefix) : message.prefix;\n            return object;\n        };\n\n        /**\n         * Converts this LeafOp to JSON.\n         * @function toJSON\n         * @memberof ics23.LeafOp\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        LeafOp.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return LeafOp;\n    })();\n\n    ics23.InnerOp = (function() {\n\n        /**\n         * Properties of an InnerOp.\n         * @memberof ics23\n         * @interface IInnerOp\n         * @property {ics23.HashOp|null} [hash] InnerOp hash\n         * @property {Uint8Array|null} [prefix] InnerOp prefix\n         * @property {Uint8Array|null} [suffix] InnerOp suffix\n         */\n\n        /**\n         * Constructs a new InnerOp.\n         * @memberof ics23\n         * @classdesc InnerOp represents a merkle-proof step that is not a leaf.\n         * It represents concatenating two children and hashing them to provide the next result.\n         * \n         * The result of the previous step is passed in, so the signature of this op is:\n         * innerOp(child) -> output\n         * \n         * The result of applying InnerOp should be:\n         * output = op.hash(op.prefix || child || op.suffix)\n         * \n         * where the || operator is concatenation of binary data,\n         * and child is the result of hashing all the tree below this step.\n         * \n         * Any special data, like prepending child with the length, or prepending the entire operation with\n         * some value to differentiate from leaf nodes, should be included in prefix and suffix.\n         * If either of prefix or suffix is empty, we just treat it as an empty string\n         * @implements IInnerOp\n         * @constructor\n         * @param {ics23.IInnerOp=} [properties] Properties to set\n         */\n        function InnerOp(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * InnerOp hash.\n         * @member {ics23.HashOp} hash\n         * @memberof ics23.InnerOp\n         * @instance\n         */\n        InnerOp.prototype.hash = 0;\n\n        /**\n         * InnerOp prefix.\n         * @member {Uint8Array} prefix\n         * @memberof ics23.InnerOp\n         * @instance\n         */\n        InnerOp.prototype.prefix = $util.newBuffer([]);\n\n        /**\n         * InnerOp suffix.\n         * @member {Uint8Array} suffix\n         * @memberof ics23.InnerOp\n         * @instance\n         */\n        InnerOp.prototype.suffix = $util.newBuffer([]);\n\n        /**\n         * Creates a new InnerOp instance using the specified properties.\n         * @function create\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {ics23.IInnerOp=} [properties] Properties to set\n         * @returns {ics23.InnerOp} InnerOp instance\n         */\n        InnerOp.create = function create(properties) {\n            return new InnerOp(properties);\n        };\n\n        /**\n         * Encodes the specified InnerOp message. Does not implicitly {@link ics23.InnerOp.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {ics23.IInnerOp} message InnerOp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        InnerOp.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.hash);\n            if (message.prefix != null && message.hasOwnProperty(\"prefix\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.prefix);\n            if (message.suffix != null && message.hasOwnProperty(\"suffix\"))\n                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.suffix);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified InnerOp message, length delimited. Does not implicitly {@link ics23.InnerOp.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {ics23.IInnerOp} message InnerOp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        InnerOp.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes an InnerOp message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.InnerOp} InnerOp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        InnerOp.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.InnerOp();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.hash = reader.int32();\n                    break;\n                case 2:\n                    message.prefix = reader.bytes();\n                    break;\n                case 3:\n                    message.suffix = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes an InnerOp message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.InnerOp} InnerOp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        InnerOp.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies an InnerOp message.\n         * @function verify\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        InnerOp.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                switch (message.hash) {\n                default:\n                    return \"hash: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 6:\n                    break;\n                }\n            if (message.prefix != null && message.hasOwnProperty(\"prefix\"))\n                if (!(message.prefix && typeof message.prefix.length === \"number\" || $util.isString(message.prefix)))\n                    return \"prefix: buffer expected\";\n            if (message.suffix != null && message.hasOwnProperty(\"suffix\"))\n                if (!(message.suffix && typeof message.suffix.length === \"number\" || $util.isString(message.suffix)))\n                    return \"suffix: buffer expected\";\n            return null;\n        };\n\n        /**\n         * Creates an InnerOp message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.InnerOp} InnerOp\n         */\n        InnerOp.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.InnerOp)\n                return object;\n            var message = new $root.ics23.InnerOp();\n            switch (object.hash) {\n            case \"NO_HASH\":\n            case 0:\n                message.hash = 0;\n                break;\n            case \"SHA256\":\n            case 1:\n                message.hash = 1;\n                break;\n            case \"SHA512\":\n            case 2:\n                message.hash = 2;\n                break;\n            case \"KECCAK\":\n            case 3:\n                message.hash = 3;\n                break;\n            case \"RIPEMD160\":\n            case 4:\n                message.hash = 4;\n                break;\n            case \"BITCOIN\":\n            case 5:\n                message.hash = 5;\n                break;\n            case \"SHA512_256\":\n            case 6:\n                message.hash = 6;\n                break;\n            }\n            if (object.prefix != null)\n                if (typeof object.prefix === \"string\")\n                    $util.base64.decode(object.prefix, message.prefix = $util.newBuffer($util.base64.length(object.prefix)), 0);\n                else if (object.prefix.length)\n                    message.prefix = object.prefix;\n            if (object.suffix != null)\n                if (typeof object.suffix === \"string\")\n                    $util.base64.decode(object.suffix, message.suffix = $util.newBuffer($util.base64.length(object.suffix)), 0);\n                else if (object.suffix.length)\n                    message.suffix = object.suffix;\n            return message;\n        };\n\n        /**\n         * Creates a plain object from an InnerOp message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {ics23.InnerOp} message InnerOp\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        InnerOp.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.hash = options.enums === String ? \"NO_HASH\" : 0;\n                if (options.bytes === String)\n                    object.prefix = \"\";\n                else {\n                    object.prefix = [];\n                    if (options.bytes !== Array)\n                        object.prefix = $util.newBuffer(object.prefix);\n                }\n                if (options.bytes === String)\n                    object.suffix = \"\";\n                else {\n                    object.suffix = [];\n                    if (options.bytes !== Array)\n                        object.suffix = $util.newBuffer(object.suffix);\n                }\n            }\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                object.hash = options.enums === String ? $root.ics23.HashOp[message.hash] : message.hash;\n            if (message.prefix != null && message.hasOwnProperty(\"prefix\"))\n                object.prefix = options.bytes === String ? $util.base64.encode(message.prefix, 0, message.prefix.length) : options.bytes === Array ? Array.prototype.slice.call(message.prefix) : message.prefix;\n            if (message.suffix != null && message.hasOwnProperty(\"suffix\"))\n                object.suffix = options.bytes === String ? $util.base64.encode(message.suffix, 0, message.suffix.length) : options.bytes === Array ? Array.prototype.slice.call(message.suffix) : message.suffix;\n            return object;\n        };\n\n        /**\n         * Converts this InnerOp to JSON.\n         * @function toJSON\n         * @memberof ics23.InnerOp\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        InnerOp.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return InnerOp;\n    })();\n\n    ics23.ProofSpec = (function() {\n\n        /**\n         * Properties of a ProofSpec.\n         * @memberof ics23\n         * @interface IProofSpec\n         * @property {ics23.ILeafOp|null} [leafSpec] ProofSpec leafSpec\n         * @property {ics23.IInnerSpec|null} [innerSpec] ProofSpec innerSpec\n         * @property {number|null} [maxDepth] ProofSpec maxDepth\n         * @property {number|null} [minDepth] ProofSpec minDepth\n         */\n\n        /**\n         * Constructs a new ProofSpec.\n         * @memberof ics23\n         * @classdesc ProofSpec defines what the expected parameters are for a given proof type.\n         * This can be stored in the client and used to validate any incoming proofs.\n         * \n         * verify(ProofSpec, Proof) -> Proof | Error\n         * \n         * As demonstrated in tests, if we don't fix the algorithm used to calculate the\n         * LeafHash for a given tree, there are many possible key-value pairs that can\n         * generate a given hash (by interpretting the preimage differently).\n         * We need this for proper security, requires client knows a priori what\n         * tree format server uses. But not in code, rather a configuration object.\n         * @implements IProofSpec\n         * @constructor\n         * @param {ics23.IProofSpec=} [properties] Properties to set\n         */\n        function ProofSpec(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * ProofSpec leafSpec.\n         * @member {ics23.ILeafOp|null|undefined} leafSpec\n         * @memberof ics23.ProofSpec\n         * @instance\n         */\n        ProofSpec.prototype.leafSpec = null;\n\n        /**\n         * ProofSpec innerSpec.\n         * @member {ics23.IInnerSpec|null|undefined} innerSpec\n         * @memberof ics23.ProofSpec\n         * @instance\n         */\n        ProofSpec.prototype.innerSpec = null;\n\n        /**\n         * ProofSpec maxDepth.\n         * @member {number} maxDepth\n         * @memberof ics23.ProofSpec\n         * @instance\n         */\n        ProofSpec.prototype.maxDepth = 0;\n\n        /**\n         * ProofSpec minDepth.\n         * @member {number} minDepth\n         * @memberof ics23.ProofSpec\n         * @instance\n         */\n        ProofSpec.prototype.minDepth = 0;\n\n        /**\n         * Creates a new ProofSpec instance using the specified properties.\n         * @function create\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {ics23.IProofSpec=} [properties] Properties to set\n         * @returns {ics23.ProofSpec} ProofSpec instance\n         */\n        ProofSpec.create = function create(properties) {\n            return new ProofSpec(properties);\n        };\n\n        /**\n         * Encodes the specified ProofSpec message. Does not implicitly {@link ics23.ProofSpec.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {ics23.IProofSpec} message ProofSpec message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ProofSpec.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.leafSpec != null && message.hasOwnProperty(\"leafSpec\"))\n                $root.ics23.LeafOp.encode(message.leafSpec, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.innerSpec != null && message.hasOwnProperty(\"innerSpec\"))\n                $root.ics23.InnerSpec.encode(message.innerSpec, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            if (message.maxDepth != null && message.hasOwnProperty(\"maxDepth\"))\n                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.maxDepth);\n            if (message.minDepth != null && message.hasOwnProperty(\"minDepth\"))\n                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.minDepth);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified ProofSpec message, length delimited. Does not implicitly {@link ics23.ProofSpec.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {ics23.IProofSpec} message ProofSpec message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ProofSpec.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a ProofSpec message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.ProofSpec} ProofSpec\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ProofSpec.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.ProofSpec();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.leafSpec = $root.ics23.LeafOp.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.innerSpec = $root.ics23.InnerSpec.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.maxDepth = reader.int32();\n                    break;\n                case 4:\n                    message.minDepth = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a ProofSpec message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.ProofSpec} ProofSpec\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ProofSpec.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a ProofSpec message.\n         * @function verify\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        ProofSpec.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.leafSpec != null && message.hasOwnProperty(\"leafSpec\")) {\n                var error = $root.ics23.LeafOp.verify(message.leafSpec);\n                if (error)\n                    return \"leafSpec.\" + error;\n            }\n            if (message.innerSpec != null && message.hasOwnProperty(\"innerSpec\")) {\n                var error = $root.ics23.InnerSpec.verify(message.innerSpec);\n                if (error)\n                    return \"innerSpec.\" + error;\n            }\n            if (message.maxDepth != null && message.hasOwnProperty(\"maxDepth\"))\n                if (!$util.isInteger(message.maxDepth))\n                    return \"maxDepth: integer expected\";\n            if (message.minDepth != null && message.hasOwnProperty(\"minDepth\"))\n                if (!$util.isInteger(message.minDepth))\n                    return \"minDepth: integer expected\";\n            return null;\n        };\n\n        /**\n         * Creates a ProofSpec message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.ProofSpec} ProofSpec\n         */\n        ProofSpec.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.ProofSpec)\n                return object;\n            var message = new $root.ics23.ProofSpec();\n            if (object.leafSpec != null) {\n                if (typeof object.leafSpec !== \"object\")\n                    throw TypeError(\".ics23.ProofSpec.leafSpec: object expected\");\n                message.leafSpec = $root.ics23.LeafOp.fromObject(object.leafSpec);\n            }\n            if (object.innerSpec != null) {\n                if (typeof object.innerSpec !== \"object\")\n                    throw TypeError(\".ics23.ProofSpec.innerSpec: object expected\");\n                message.innerSpec = $root.ics23.InnerSpec.fromObject(object.innerSpec);\n            }\n            if (object.maxDepth != null)\n                message.maxDepth = object.maxDepth | 0;\n            if (object.minDepth != null)\n                message.minDepth = object.minDepth | 0;\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a ProofSpec message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {ics23.ProofSpec} message ProofSpec\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        ProofSpec.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.leafSpec = null;\n                object.innerSpec = null;\n                object.maxDepth = 0;\n                object.minDepth = 0;\n            }\n            if (message.leafSpec != null && message.hasOwnProperty(\"leafSpec\"))\n                object.leafSpec = $root.ics23.LeafOp.toObject(message.leafSpec, options);\n            if (message.innerSpec != null && message.hasOwnProperty(\"innerSpec\"))\n                object.innerSpec = $root.ics23.InnerSpec.toObject(message.innerSpec, options);\n            if (message.maxDepth != null && message.hasOwnProperty(\"maxDepth\"))\n                object.maxDepth = message.maxDepth;\n            if (message.minDepth != null && message.hasOwnProperty(\"minDepth\"))\n                object.minDepth = message.minDepth;\n            return object;\n        };\n\n        /**\n         * Converts this ProofSpec to JSON.\n         * @function toJSON\n         * @memberof ics23.ProofSpec\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        ProofSpec.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return ProofSpec;\n    })();\n\n    ics23.InnerSpec = (function() {\n\n        /**\n         * Properties of an InnerSpec.\n         * @memberof ics23\n         * @interface IInnerSpec\n         * @property {Array.<number>|null} [childOrder] InnerSpec childOrder\n         * @property {number|null} [childSize] InnerSpec childSize\n         * @property {number|null} [minPrefixLength] InnerSpec minPrefixLength\n         * @property {number|null} [maxPrefixLength] InnerSpec maxPrefixLength\n         * @property {Uint8Array|null} [emptyChild] InnerSpec emptyChild\n         * @property {ics23.HashOp|null} [hash] InnerSpec hash\n         */\n\n        /**\n         * Constructs a new InnerSpec.\n         * @memberof ics23\n         * @classdesc Represents an InnerSpec.\n         * @implements IInnerSpec\n         * @constructor\n         * @param {ics23.IInnerSpec=} [properties] Properties to set\n         */\n        function InnerSpec(properties) {\n            this.childOrder = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * InnerSpec childOrder.\n         * @member {Array.<number>} childOrder\n         * @memberof ics23.InnerSpec\n         * @instance\n         */\n        InnerSpec.prototype.childOrder = $util.emptyArray;\n\n        /**\n         * InnerSpec childSize.\n         * @member {number} childSize\n         * @memberof ics23.InnerSpec\n         * @instance\n         */\n        InnerSpec.prototype.childSize = 0;\n\n        /**\n         * InnerSpec minPrefixLength.\n         * @member {number} minPrefixLength\n         * @memberof ics23.InnerSpec\n         * @instance\n         */\n        InnerSpec.prototype.minPrefixLength = 0;\n\n        /**\n         * InnerSpec maxPrefixLength.\n         * @member {number} maxPrefixLength\n         * @memberof ics23.InnerSpec\n         * @instance\n         */\n        InnerSpec.prototype.maxPrefixLength = 0;\n\n        /**\n         * InnerSpec emptyChild.\n         * @member {Uint8Array} emptyChild\n         * @memberof ics23.InnerSpec\n         * @instance\n         */\n        InnerSpec.prototype.emptyChild = $util.newBuffer([]);\n\n        /**\n         * InnerSpec hash.\n         * @member {ics23.HashOp} hash\n         * @memberof ics23.InnerSpec\n         * @instance\n         */\n        InnerSpec.prototype.hash = 0;\n\n        /**\n         * Creates a new InnerSpec instance using the specified properties.\n         * @function create\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {ics23.IInnerSpec=} [properties] Properties to set\n         * @returns {ics23.InnerSpec} InnerSpec instance\n         */\n        InnerSpec.create = function create(properties) {\n            return new InnerSpec(properties);\n        };\n\n        /**\n         * Encodes the specified InnerSpec message. Does not implicitly {@link ics23.InnerSpec.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {ics23.IInnerSpec} message InnerSpec message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        InnerSpec.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.childOrder != null && message.childOrder.length) {\n                writer.uint32(/* id 1, wireType 2 =*/10).fork();\n                for (var i = 0; i < message.childOrder.length; ++i)\n                    writer.int32(message.childOrder[i]);\n                writer.ldelim();\n            }\n            if (message.childSize != null && message.hasOwnProperty(\"childSize\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.childSize);\n            if (message.minPrefixLength != null && message.hasOwnProperty(\"minPrefixLength\"))\n                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.minPrefixLength);\n            if (message.maxPrefixLength != null && message.hasOwnProperty(\"maxPrefixLength\"))\n                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.maxPrefixLength);\n            if (message.emptyChild != null && message.hasOwnProperty(\"emptyChild\"))\n                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.emptyChild);\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.hash);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified InnerSpec message, length delimited. Does not implicitly {@link ics23.InnerSpec.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {ics23.IInnerSpec} message InnerSpec message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        InnerSpec.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes an InnerSpec message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.InnerSpec} InnerSpec\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        InnerSpec.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.InnerSpec();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    if (!(message.childOrder && message.childOrder.length))\n                        message.childOrder = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.childOrder.push(reader.int32());\n                    } else\n                        message.childOrder.push(reader.int32());\n                    break;\n                case 2:\n                    message.childSize = reader.int32();\n                    break;\n                case 3:\n                    message.minPrefixLength = reader.int32();\n                    break;\n                case 4:\n                    message.maxPrefixLength = reader.int32();\n                    break;\n                case 5:\n                    message.emptyChild = reader.bytes();\n                    break;\n                case 6:\n                    message.hash = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes an InnerSpec message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.InnerSpec} InnerSpec\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        InnerSpec.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies an InnerSpec message.\n         * @function verify\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        InnerSpec.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.childOrder != null && message.hasOwnProperty(\"childOrder\")) {\n                if (!Array.isArray(message.childOrder))\n                    return \"childOrder: array expected\";\n                for (var i = 0; i < message.childOrder.length; ++i)\n                    if (!$util.isInteger(message.childOrder[i]))\n                        return \"childOrder: integer[] expected\";\n            }\n            if (message.childSize != null && message.hasOwnProperty(\"childSize\"))\n                if (!$util.isInteger(message.childSize))\n                    return \"childSize: integer expected\";\n            if (message.minPrefixLength != null && message.hasOwnProperty(\"minPrefixLength\"))\n                if (!$util.isInteger(message.minPrefixLength))\n                    return \"minPrefixLength: integer expected\";\n            if (message.maxPrefixLength != null && message.hasOwnProperty(\"maxPrefixLength\"))\n                if (!$util.isInteger(message.maxPrefixLength))\n                    return \"maxPrefixLength: integer expected\";\n            if (message.emptyChild != null && message.hasOwnProperty(\"emptyChild\"))\n                if (!(message.emptyChild && typeof message.emptyChild.length === \"number\" || $util.isString(message.emptyChild)))\n                    return \"emptyChild: buffer expected\";\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                switch (message.hash) {\n                default:\n                    return \"hash: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 6:\n                    break;\n                }\n            return null;\n        };\n\n        /**\n         * Creates an InnerSpec message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.InnerSpec} InnerSpec\n         */\n        InnerSpec.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.InnerSpec)\n                return object;\n            var message = new $root.ics23.InnerSpec();\n            if (object.childOrder) {\n                if (!Array.isArray(object.childOrder))\n                    throw TypeError(\".ics23.InnerSpec.childOrder: array expected\");\n                message.childOrder = [];\n                for (var i = 0; i < object.childOrder.length; ++i)\n                    message.childOrder[i] = object.childOrder[i] | 0;\n            }\n            if (object.childSize != null)\n                message.childSize = object.childSize | 0;\n            if (object.minPrefixLength != null)\n                message.minPrefixLength = object.minPrefixLength | 0;\n            if (object.maxPrefixLength != null)\n                message.maxPrefixLength = object.maxPrefixLength | 0;\n            if (object.emptyChild != null)\n                if (typeof object.emptyChild === \"string\")\n                    $util.base64.decode(object.emptyChild, message.emptyChild = $util.newBuffer($util.base64.length(object.emptyChild)), 0);\n                else if (object.emptyChild.length)\n                    message.emptyChild = object.emptyChild;\n            switch (object.hash) {\n            case \"NO_HASH\":\n            case 0:\n                message.hash = 0;\n                break;\n            case \"SHA256\":\n            case 1:\n                message.hash = 1;\n                break;\n            case \"SHA512\":\n            case 2:\n                message.hash = 2;\n                break;\n            case \"KECCAK\":\n            case 3:\n                message.hash = 3;\n                break;\n            case \"RIPEMD160\":\n            case 4:\n                message.hash = 4;\n                break;\n            case \"BITCOIN\":\n            case 5:\n                message.hash = 5;\n                break;\n            case \"SHA512_256\":\n            case 6:\n                message.hash = 6;\n                break;\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from an InnerSpec message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {ics23.InnerSpec} message InnerSpec\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        InnerSpec.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults)\n                object.childOrder = [];\n            if (options.defaults) {\n                object.childSize = 0;\n                object.minPrefixLength = 0;\n                object.maxPrefixLength = 0;\n                if (options.bytes === String)\n                    object.emptyChild = \"\";\n                else {\n                    object.emptyChild = [];\n                    if (options.bytes !== Array)\n                        object.emptyChild = $util.newBuffer(object.emptyChild);\n                }\n                object.hash = options.enums === String ? \"NO_HASH\" : 0;\n            }\n            if (message.childOrder && message.childOrder.length) {\n                object.childOrder = [];\n                for (var j = 0; j < message.childOrder.length; ++j)\n                    object.childOrder[j] = message.childOrder[j];\n            }\n            if (message.childSize != null && message.hasOwnProperty(\"childSize\"))\n                object.childSize = message.childSize;\n            if (message.minPrefixLength != null && message.hasOwnProperty(\"minPrefixLength\"))\n                object.minPrefixLength = message.minPrefixLength;\n            if (message.maxPrefixLength != null && message.hasOwnProperty(\"maxPrefixLength\"))\n                object.maxPrefixLength = message.maxPrefixLength;\n            if (message.emptyChild != null && message.hasOwnProperty(\"emptyChild\"))\n                object.emptyChild = options.bytes === String ? $util.base64.encode(message.emptyChild, 0, message.emptyChild.length) : options.bytes === Array ? Array.prototype.slice.call(message.emptyChild) : message.emptyChild;\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                object.hash = options.enums === String ? $root.ics23.HashOp[message.hash] : message.hash;\n            return object;\n        };\n\n        /**\n         * Converts this InnerSpec to JSON.\n         * @function toJSON\n         * @memberof ics23.InnerSpec\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        InnerSpec.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return InnerSpec;\n    })();\n\n    ics23.BatchProof = (function() {\n\n        /**\n         * Properties of a BatchProof.\n         * @memberof ics23\n         * @interface IBatchProof\n         * @property {Array.<ics23.IBatchEntry>|null} [entries] BatchProof entries\n         */\n\n        /**\n         * Constructs a new BatchProof.\n         * @memberof ics23\n         * @classdesc Represents a BatchProof.\n         * @implements IBatchProof\n         * @constructor\n         * @param {ics23.IBatchProof=} [properties] Properties to set\n         */\n        function BatchProof(properties) {\n            this.entries = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * BatchProof entries.\n         * @member {Array.<ics23.IBatchEntry>} entries\n         * @memberof ics23.BatchProof\n         * @instance\n         */\n        BatchProof.prototype.entries = $util.emptyArray;\n\n        /**\n         * Creates a new BatchProof instance using the specified properties.\n         * @function create\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {ics23.IBatchProof=} [properties] Properties to set\n         * @returns {ics23.BatchProof} BatchProof instance\n         */\n        BatchProof.create = function create(properties) {\n            return new BatchProof(properties);\n        };\n\n        /**\n         * Encodes the specified BatchProof message. Does not implicitly {@link ics23.BatchProof.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {ics23.IBatchProof} message BatchProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BatchProof.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.entries != null && message.entries.length)\n                for (var i = 0; i < message.entries.length; ++i)\n                    $root.ics23.BatchEntry.encode(message.entries[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified BatchProof message, length delimited. Does not implicitly {@link ics23.BatchProof.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {ics23.IBatchProof} message BatchProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BatchProof.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a BatchProof message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.BatchProof} BatchProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BatchProof.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.BatchProof();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    if (!(message.entries && message.entries.length))\n                        message.entries = [];\n                    message.entries.push($root.ics23.BatchEntry.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a BatchProof message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.BatchProof} BatchProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BatchProof.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a BatchProof message.\n         * @function verify\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        BatchProof.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.entries != null && message.hasOwnProperty(\"entries\")) {\n                if (!Array.isArray(message.entries))\n                    return \"entries: array expected\";\n                for (var i = 0; i < message.entries.length; ++i) {\n                    var error = $root.ics23.BatchEntry.verify(message.entries[i]);\n                    if (error)\n                        return \"entries.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a BatchProof message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.BatchProof} BatchProof\n         */\n        BatchProof.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.BatchProof)\n                return object;\n            var message = new $root.ics23.BatchProof();\n            if (object.entries) {\n                if (!Array.isArray(object.entries))\n                    throw TypeError(\".ics23.BatchProof.entries: array expected\");\n                message.entries = [];\n                for (var i = 0; i < object.entries.length; ++i) {\n                    if (typeof object.entries[i] !== \"object\")\n                        throw TypeError(\".ics23.BatchProof.entries: object expected\");\n                    message.entries[i] = $root.ics23.BatchEntry.fromObject(object.entries[i]);\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a BatchProof message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {ics23.BatchProof} message BatchProof\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        BatchProof.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults)\n                object.entries = [];\n            if (message.entries && message.entries.length) {\n                object.entries = [];\n                for (var j = 0; j < message.entries.length; ++j)\n                    object.entries[j] = $root.ics23.BatchEntry.toObject(message.entries[j], options);\n            }\n            return object;\n        };\n\n        /**\n         * Converts this BatchProof to JSON.\n         * @function toJSON\n         * @memberof ics23.BatchProof\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        BatchProof.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return BatchProof;\n    })();\n\n    ics23.BatchEntry = (function() {\n\n        /**\n         * Properties of a BatchEntry.\n         * @memberof ics23\n         * @interface IBatchEntry\n         * @property {ics23.IExistenceProof|null} [exist] BatchEntry exist\n         * @property {ics23.INonExistenceProof|null} [nonexist] BatchEntry nonexist\n         */\n\n        /**\n         * Constructs a new BatchEntry.\n         * @memberof ics23\n         * @classdesc Represents a BatchEntry.\n         * @implements IBatchEntry\n         * @constructor\n         * @param {ics23.IBatchEntry=} [properties] Properties to set\n         */\n        function BatchEntry(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * BatchEntry exist.\n         * @member {ics23.IExistenceProof|null|undefined} exist\n         * @memberof ics23.BatchEntry\n         * @instance\n         */\n        BatchEntry.prototype.exist = null;\n\n        /**\n         * BatchEntry nonexist.\n         * @member {ics23.INonExistenceProof|null|undefined} nonexist\n         * @memberof ics23.BatchEntry\n         * @instance\n         */\n        BatchEntry.prototype.nonexist = null;\n\n        // OneOf field names bound to virtual getters and setters\n        var $oneOfFields;\n\n        /**\n         * BatchEntry proof.\n         * @member {\"exist\"|\"nonexist\"|undefined} proof\n         * @memberof ics23.BatchEntry\n         * @instance\n         */\n        Object.defineProperty(BatchEntry.prototype, \"proof\", {\n            get: $util.oneOfGetter($oneOfFields = [\"exist\", \"nonexist\"]),\n            set: $util.oneOfSetter($oneOfFields)\n        });\n\n        /**\n         * Creates a new BatchEntry instance using the specified properties.\n         * @function create\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {ics23.IBatchEntry=} [properties] Properties to set\n         * @returns {ics23.BatchEntry} BatchEntry instance\n         */\n        BatchEntry.create = function create(properties) {\n            return new BatchEntry(properties);\n        };\n\n        /**\n         * Encodes the specified BatchEntry message. Does not implicitly {@link ics23.BatchEntry.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {ics23.IBatchEntry} message BatchEntry message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BatchEntry.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.exist != null && message.hasOwnProperty(\"exist\"))\n                $root.ics23.ExistenceProof.encode(message.exist, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\"))\n                $root.ics23.NonExistenceProof.encode(message.nonexist, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified BatchEntry message, length delimited. Does not implicitly {@link ics23.BatchEntry.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {ics23.IBatchEntry} message BatchEntry message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BatchEntry.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a BatchEntry message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.BatchEntry} BatchEntry\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BatchEntry.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.BatchEntry();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.exist = $root.ics23.ExistenceProof.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.nonexist = $root.ics23.NonExistenceProof.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a BatchEntry message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.BatchEntry} BatchEntry\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BatchEntry.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a BatchEntry message.\n         * @function verify\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        BatchEntry.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            var properties = {};\n            if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.ExistenceProof.verify(message.exist);\n                    if (error)\n                        return \"exist.\" + error;\n                }\n            }\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n                if (properties.proof === 1)\n                    return \"proof: multiple values\";\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.NonExistenceProof.verify(message.nonexist);\n                    if (error)\n                        return \"nonexist.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a BatchEntry message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.BatchEntry} BatchEntry\n         */\n        BatchEntry.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.BatchEntry)\n                return object;\n            var message = new $root.ics23.BatchEntry();\n            if (object.exist != null) {\n                if (typeof object.exist !== \"object\")\n                    throw TypeError(\".ics23.BatchEntry.exist: object expected\");\n                message.exist = $root.ics23.ExistenceProof.fromObject(object.exist);\n            }\n            if (object.nonexist != null) {\n                if (typeof object.nonexist !== \"object\")\n                    throw TypeError(\".ics23.BatchEntry.nonexist: object expected\");\n                message.nonexist = $root.ics23.NonExistenceProof.fromObject(object.nonexist);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a BatchEntry message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {ics23.BatchEntry} message BatchEntry\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        BatchEntry.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n                object.exist = $root.ics23.ExistenceProof.toObject(message.exist, options);\n                if (options.oneofs)\n                    object.proof = \"exist\";\n            }\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n                object.nonexist = $root.ics23.NonExistenceProof.toObject(message.nonexist, options);\n                if (options.oneofs)\n                    object.proof = \"nonexist\";\n            }\n            return object;\n        };\n\n        /**\n         * Converts this BatchEntry to JSON.\n         * @function toJSON\n         * @memberof ics23.BatchEntry\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        BatchEntry.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return BatchEntry;\n    })();\n\n    ics23.CompressedBatchProof = (function() {\n\n        /**\n         * Properties of a CompressedBatchProof.\n         * @memberof ics23\n         * @interface ICompressedBatchProof\n         * @property {Array.<ics23.ICompressedBatchEntry>|null} [entries] CompressedBatchProof entries\n         * @property {Array.<ics23.IInnerOp>|null} [lookupInners] CompressedBatchProof lookupInners\n         */\n\n        /**\n         * Constructs a new CompressedBatchProof.\n         * @memberof ics23\n         * @classdesc Represents a CompressedBatchProof.\n         * @implements ICompressedBatchProof\n         * @constructor\n         * @param {ics23.ICompressedBatchProof=} [properties] Properties to set\n         */\n        function CompressedBatchProof(properties) {\n            this.entries = [];\n            this.lookupInners = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * CompressedBatchProof entries.\n         * @member {Array.<ics23.ICompressedBatchEntry>} entries\n         * @memberof ics23.CompressedBatchProof\n         * @instance\n         */\n        CompressedBatchProof.prototype.entries = $util.emptyArray;\n\n        /**\n         * CompressedBatchProof lookupInners.\n         * @member {Array.<ics23.IInnerOp>} lookupInners\n         * @memberof ics23.CompressedBatchProof\n         * @instance\n         */\n        CompressedBatchProof.prototype.lookupInners = $util.emptyArray;\n\n        /**\n         * Creates a new CompressedBatchProof instance using the specified properties.\n         * @function create\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {ics23.ICompressedBatchProof=} [properties] Properties to set\n         * @returns {ics23.CompressedBatchProof} CompressedBatchProof instance\n         */\n        CompressedBatchProof.create = function create(properties) {\n            return new CompressedBatchProof(properties);\n        };\n\n        /**\n         * Encodes the specified CompressedBatchProof message. Does not implicitly {@link ics23.CompressedBatchProof.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {ics23.ICompressedBatchProof} message CompressedBatchProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedBatchProof.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.entries != null && message.entries.length)\n                for (var i = 0; i < message.entries.length; ++i)\n                    $root.ics23.CompressedBatchEntry.encode(message.entries[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.lookupInners != null && message.lookupInners.length)\n                for (var i = 0; i < message.lookupInners.length; ++i)\n                    $root.ics23.InnerOp.encode(message.lookupInners[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified CompressedBatchProof message, length delimited. Does not implicitly {@link ics23.CompressedBatchProof.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {ics23.ICompressedBatchProof} message CompressedBatchProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedBatchProof.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a CompressedBatchProof message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.CompressedBatchProof} CompressedBatchProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedBatchProof.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.CompressedBatchProof();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    if (!(message.entries && message.entries.length))\n                        message.entries = [];\n                    message.entries.push($root.ics23.CompressedBatchEntry.decode(reader, reader.uint32()));\n                    break;\n                case 2:\n                    if (!(message.lookupInners && message.lookupInners.length))\n                        message.lookupInners = [];\n                    message.lookupInners.push($root.ics23.InnerOp.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a CompressedBatchProof message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.CompressedBatchProof} CompressedBatchProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedBatchProof.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a CompressedBatchProof message.\n         * @function verify\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        CompressedBatchProof.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.entries != null && message.hasOwnProperty(\"entries\")) {\n                if (!Array.isArray(message.entries))\n                    return \"entries: array expected\";\n                for (var i = 0; i < message.entries.length; ++i) {\n                    var error = $root.ics23.CompressedBatchEntry.verify(message.entries[i]);\n                    if (error)\n                        return \"entries.\" + error;\n                }\n            }\n            if (message.lookupInners != null && message.hasOwnProperty(\"lookupInners\")) {\n                if (!Array.isArray(message.lookupInners))\n                    return \"lookupInners: array expected\";\n                for (var i = 0; i < message.lookupInners.length; ++i) {\n                    var error = $root.ics23.InnerOp.verify(message.lookupInners[i]);\n                    if (error)\n                        return \"lookupInners.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a CompressedBatchProof message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.CompressedBatchProof} CompressedBatchProof\n         */\n        CompressedBatchProof.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.CompressedBatchProof)\n                return object;\n            var message = new $root.ics23.CompressedBatchProof();\n            if (object.entries) {\n                if (!Array.isArray(object.entries))\n                    throw TypeError(\".ics23.CompressedBatchProof.entries: array expected\");\n                message.entries = [];\n                for (var i = 0; i < object.entries.length; ++i) {\n                    if (typeof object.entries[i] !== \"object\")\n                        throw TypeError(\".ics23.CompressedBatchProof.entries: object expected\");\n                    message.entries[i] = $root.ics23.CompressedBatchEntry.fromObject(object.entries[i]);\n                }\n            }\n            if (object.lookupInners) {\n                if (!Array.isArray(object.lookupInners))\n                    throw TypeError(\".ics23.CompressedBatchProof.lookupInners: array expected\");\n                message.lookupInners = [];\n                for (var i = 0; i < object.lookupInners.length; ++i) {\n                    if (typeof object.lookupInners[i] !== \"object\")\n                        throw TypeError(\".ics23.CompressedBatchProof.lookupInners: object expected\");\n                    message.lookupInners[i] = $root.ics23.InnerOp.fromObject(object.lookupInners[i]);\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a CompressedBatchProof message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {ics23.CompressedBatchProof} message CompressedBatchProof\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        CompressedBatchProof.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults) {\n                object.entries = [];\n                object.lookupInners = [];\n            }\n            if (message.entries && message.entries.length) {\n                object.entries = [];\n                for (var j = 0; j < message.entries.length; ++j)\n                    object.entries[j] = $root.ics23.CompressedBatchEntry.toObject(message.entries[j], options);\n            }\n            if (message.lookupInners && message.lookupInners.length) {\n                object.lookupInners = [];\n                for (var j = 0; j < message.lookupInners.length; ++j)\n                    object.lookupInners[j] = $root.ics23.InnerOp.toObject(message.lookupInners[j], options);\n            }\n            return object;\n        };\n\n        /**\n         * Converts this CompressedBatchProof to JSON.\n         * @function toJSON\n         * @memberof ics23.CompressedBatchProof\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        CompressedBatchProof.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return CompressedBatchProof;\n    })();\n\n    ics23.CompressedBatchEntry = (function() {\n\n        /**\n         * Properties of a CompressedBatchEntry.\n         * @memberof ics23\n         * @interface ICompressedBatchEntry\n         * @property {ics23.ICompressedExistenceProof|null} [exist] CompressedBatchEntry exist\n         * @property {ics23.ICompressedNonExistenceProof|null} [nonexist] CompressedBatchEntry nonexist\n         */\n\n        /**\n         * Constructs a new CompressedBatchEntry.\n         * @memberof ics23\n         * @classdesc Represents a CompressedBatchEntry.\n         * @implements ICompressedBatchEntry\n         * @constructor\n         * @param {ics23.ICompressedBatchEntry=} [properties] Properties to set\n         */\n        function CompressedBatchEntry(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * CompressedBatchEntry exist.\n         * @member {ics23.ICompressedExistenceProof|null|undefined} exist\n         * @memberof ics23.CompressedBatchEntry\n         * @instance\n         */\n        CompressedBatchEntry.prototype.exist = null;\n\n        /**\n         * CompressedBatchEntry nonexist.\n         * @member {ics23.ICompressedNonExistenceProof|null|undefined} nonexist\n         * @memberof ics23.CompressedBatchEntry\n         * @instance\n         */\n        CompressedBatchEntry.prototype.nonexist = null;\n\n        // OneOf field names bound to virtual getters and setters\n        var $oneOfFields;\n\n        /**\n         * CompressedBatchEntry proof.\n         * @member {\"exist\"|\"nonexist\"|undefined} proof\n         * @memberof ics23.CompressedBatchEntry\n         * @instance\n         */\n        Object.defineProperty(CompressedBatchEntry.prototype, \"proof\", {\n            get: $util.oneOfGetter($oneOfFields = [\"exist\", \"nonexist\"]),\n            set: $util.oneOfSetter($oneOfFields)\n        });\n\n        /**\n         * Creates a new CompressedBatchEntry instance using the specified properties.\n         * @function create\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {ics23.ICompressedBatchEntry=} [properties] Properties to set\n         * @returns {ics23.CompressedBatchEntry} CompressedBatchEntry instance\n         */\n        CompressedBatchEntry.create = function create(properties) {\n            return new CompressedBatchEntry(properties);\n        };\n\n        /**\n         * Encodes the specified CompressedBatchEntry message. Does not implicitly {@link ics23.CompressedBatchEntry.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {ics23.ICompressedBatchEntry} message CompressedBatchEntry message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedBatchEntry.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.exist != null && message.hasOwnProperty(\"exist\"))\n                $root.ics23.CompressedExistenceProof.encode(message.exist, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\"))\n                $root.ics23.CompressedNonExistenceProof.encode(message.nonexist, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified CompressedBatchEntry message, length delimited. Does not implicitly {@link ics23.CompressedBatchEntry.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {ics23.ICompressedBatchEntry} message CompressedBatchEntry message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedBatchEntry.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a CompressedBatchEntry message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.CompressedBatchEntry} CompressedBatchEntry\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedBatchEntry.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.CompressedBatchEntry();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.exist = $root.ics23.CompressedExistenceProof.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.nonexist = $root.ics23.CompressedNonExistenceProof.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a CompressedBatchEntry message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.CompressedBatchEntry} CompressedBatchEntry\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedBatchEntry.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a CompressedBatchEntry message.\n         * @function verify\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        CompressedBatchEntry.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            var properties = {};\n            if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.CompressedExistenceProof.verify(message.exist);\n                    if (error)\n                        return \"exist.\" + error;\n                }\n            }\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n                if (properties.proof === 1)\n                    return \"proof: multiple values\";\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.CompressedNonExistenceProof.verify(message.nonexist);\n                    if (error)\n                        return \"nonexist.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a CompressedBatchEntry message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.CompressedBatchEntry} CompressedBatchEntry\n         */\n        CompressedBatchEntry.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.CompressedBatchEntry)\n                return object;\n            var message = new $root.ics23.CompressedBatchEntry();\n            if (object.exist != null) {\n                if (typeof object.exist !== \"object\")\n                    throw TypeError(\".ics23.CompressedBatchEntry.exist: object expected\");\n                message.exist = $root.ics23.CompressedExistenceProof.fromObject(object.exist);\n            }\n            if (object.nonexist != null) {\n                if (typeof object.nonexist !== \"object\")\n                    throw TypeError(\".ics23.CompressedBatchEntry.nonexist: object expected\");\n                message.nonexist = $root.ics23.CompressedNonExistenceProof.fromObject(object.nonexist);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a CompressedBatchEntry message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {ics23.CompressedBatchEntry} message CompressedBatchEntry\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        CompressedBatchEntry.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n                object.exist = $root.ics23.CompressedExistenceProof.toObject(message.exist, options);\n                if (options.oneofs)\n                    object.proof = \"exist\";\n            }\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n                object.nonexist = $root.ics23.CompressedNonExistenceProof.toObject(message.nonexist, options);\n                if (options.oneofs)\n                    object.proof = \"nonexist\";\n            }\n            return object;\n        };\n\n        /**\n         * Converts this CompressedBatchEntry to JSON.\n         * @function toJSON\n         * @memberof ics23.CompressedBatchEntry\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        CompressedBatchEntry.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return CompressedBatchEntry;\n    })();\n\n    ics23.CompressedExistenceProof = (function() {\n\n        /**\n         * Properties of a CompressedExistenceProof.\n         * @memberof ics23\n         * @interface ICompressedExistenceProof\n         * @property {Uint8Array|null} [key] CompressedExistenceProof key\n         * @property {Uint8Array|null} [value] CompressedExistenceProof value\n         * @property {ics23.ILeafOp|null} [leaf] CompressedExistenceProof leaf\n         * @property {Array.<number>|null} [path] CompressedExistenceProof path\n         */\n\n        /**\n         * Constructs a new CompressedExistenceProof.\n         * @memberof ics23\n         * @classdesc Represents a CompressedExistenceProof.\n         * @implements ICompressedExistenceProof\n         * @constructor\n         * @param {ics23.ICompressedExistenceProof=} [properties] Properties to set\n         */\n        function CompressedExistenceProof(properties) {\n            this.path = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * CompressedExistenceProof key.\n         * @member {Uint8Array} key\n         * @memberof ics23.CompressedExistenceProof\n         * @instance\n         */\n        CompressedExistenceProof.prototype.key = $util.newBuffer([]);\n\n        /**\n         * CompressedExistenceProof value.\n         * @member {Uint8Array} value\n         * @memberof ics23.CompressedExistenceProof\n         * @instance\n         */\n        CompressedExistenceProof.prototype.value = $util.newBuffer([]);\n\n        /**\n         * CompressedExistenceProof leaf.\n         * @member {ics23.ILeafOp|null|undefined} leaf\n         * @memberof ics23.CompressedExistenceProof\n         * @instance\n         */\n        CompressedExistenceProof.prototype.leaf = null;\n\n        /**\n         * CompressedExistenceProof path.\n         * @member {Array.<number>} path\n         * @memberof ics23.CompressedExistenceProof\n         * @instance\n         */\n        CompressedExistenceProof.prototype.path = $util.emptyArray;\n\n        /**\n         * Creates a new CompressedExistenceProof instance using the specified properties.\n         * @function create\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {ics23.ICompressedExistenceProof=} [properties] Properties to set\n         * @returns {ics23.CompressedExistenceProof} CompressedExistenceProof instance\n         */\n        CompressedExistenceProof.create = function create(properties) {\n            return new CompressedExistenceProof(properties);\n        };\n\n        /**\n         * Encodes the specified CompressedExistenceProof message. Does not implicitly {@link ics23.CompressedExistenceProof.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {ics23.ICompressedExistenceProof} message CompressedExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedExistenceProof.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);\n            if (message.value != null && message.hasOwnProperty(\"value\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);\n            if (message.leaf != null && message.hasOwnProperty(\"leaf\"))\n                $root.ics23.LeafOp.encode(message.leaf, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n            if (message.path != null && message.path.length) {\n                writer.uint32(/* id 4, wireType 2 =*/34).fork();\n                for (var i = 0; i < message.path.length; ++i)\n                    writer.int32(message.path[i]);\n                writer.ldelim();\n            }\n            return writer;\n        };\n\n        /**\n         * Encodes the specified CompressedExistenceProof message, length delimited. Does not implicitly {@link ics23.CompressedExistenceProof.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {ics23.ICompressedExistenceProof} message CompressedExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a CompressedExistenceProof message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.CompressedExistenceProof} CompressedExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedExistenceProof.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.CompressedExistenceProof();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.bytes();\n                    break;\n                case 2:\n                    message.value = reader.bytes();\n                    break;\n                case 3:\n                    message.leaf = $root.ics23.LeafOp.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    if (!(message.path && message.path.length))\n                        message.path = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.path.push(reader.int32());\n                    } else\n                        message.path.push(reader.int32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a CompressedExistenceProof message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.CompressedExistenceProof} CompressedExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedExistenceProof.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a CompressedExistenceProof message.\n         * @function verify\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        CompressedExistenceProof.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                if (!(message.key && typeof message.key.length === \"number\" || $util.isString(message.key)))\n                    return \"key: buffer expected\";\n            if (message.value != null && message.hasOwnProperty(\"value\"))\n                if (!(message.value && typeof message.value.length === \"number\" || $util.isString(message.value)))\n                    return \"value: buffer expected\";\n            if (message.leaf != null && message.hasOwnProperty(\"leaf\")) {\n                var error = $root.ics23.LeafOp.verify(message.leaf);\n                if (error)\n                    return \"leaf.\" + error;\n            }\n            if (message.path != null && message.hasOwnProperty(\"path\")) {\n                if (!Array.isArray(message.path))\n                    return \"path: array expected\";\n                for (var i = 0; i < message.path.length; ++i)\n                    if (!$util.isInteger(message.path[i]))\n                        return \"path: integer[] expected\";\n            }\n            return null;\n        };\n\n        /**\n         * Creates a CompressedExistenceProof message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.CompressedExistenceProof} CompressedExistenceProof\n         */\n        CompressedExistenceProof.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.CompressedExistenceProof)\n                return object;\n            var message = new $root.ics23.CompressedExistenceProof();\n            if (object.key != null)\n                if (typeof object.key === \"string\")\n                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);\n                else if (object.key.length)\n                    message.key = object.key;\n            if (object.value != null)\n                if (typeof object.value === \"string\")\n                    $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);\n                else if (object.value.length)\n                    message.value = object.value;\n            if (object.leaf != null) {\n                if (typeof object.leaf !== \"object\")\n                    throw TypeError(\".ics23.CompressedExistenceProof.leaf: object expected\");\n                message.leaf = $root.ics23.LeafOp.fromObject(object.leaf);\n            }\n            if (object.path) {\n                if (!Array.isArray(object.path))\n                    throw TypeError(\".ics23.CompressedExistenceProof.path: array expected\");\n                message.path = [];\n                for (var i = 0; i < object.path.length; ++i)\n                    message.path[i] = object.path[i] | 0;\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a CompressedExistenceProof message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {ics23.CompressedExistenceProof} message CompressedExistenceProof\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        CompressedExistenceProof.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults)\n                object.path = [];\n            if (options.defaults) {\n                if (options.bytes === String)\n                    object.key = \"\";\n                else {\n                    object.key = [];\n                    if (options.bytes !== Array)\n                        object.key = $util.newBuffer(object.key);\n                }\n                if (options.bytes === String)\n                    object.value = \"\";\n                else {\n                    object.value = [];\n                    if (options.bytes !== Array)\n                        object.value = $util.newBuffer(object.value);\n                }\n                object.leaf = null;\n            }\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;\n            if (message.value != null && message.hasOwnProperty(\"value\"))\n                object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;\n            if (message.leaf != null && message.hasOwnProperty(\"leaf\"))\n                object.leaf = $root.ics23.LeafOp.toObject(message.leaf, options);\n            if (message.path && message.path.length) {\n                object.path = [];\n                for (var j = 0; j < message.path.length; ++j)\n                    object.path[j] = message.path[j];\n            }\n            return object;\n        };\n\n        /**\n         * Converts this CompressedExistenceProof to JSON.\n         * @function toJSON\n         * @memberof ics23.CompressedExistenceProof\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        CompressedExistenceProof.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return CompressedExistenceProof;\n    })();\n\n    ics23.CompressedNonExistenceProof = (function() {\n\n        /**\n         * Properties of a CompressedNonExistenceProof.\n         * @memberof ics23\n         * @interface ICompressedNonExistenceProof\n         * @property {Uint8Array|null} [key] CompressedNonExistenceProof key\n         * @property {ics23.ICompressedExistenceProof|null} [left] CompressedNonExistenceProof left\n         * @property {ics23.ICompressedExistenceProof|null} [right] CompressedNonExistenceProof right\n         */\n\n        /**\n         * Constructs a new CompressedNonExistenceProof.\n         * @memberof ics23\n         * @classdesc Represents a CompressedNonExistenceProof.\n         * @implements ICompressedNonExistenceProof\n         * @constructor\n         * @param {ics23.ICompressedNonExistenceProof=} [properties] Properties to set\n         */\n        function CompressedNonExistenceProof(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * CompressedNonExistenceProof key.\n         * @member {Uint8Array} key\n         * @memberof ics23.CompressedNonExistenceProof\n         * @instance\n         */\n        CompressedNonExistenceProof.prototype.key = $util.newBuffer([]);\n\n        /**\n         * CompressedNonExistenceProof left.\n         * @member {ics23.ICompressedExistenceProof|null|undefined} left\n         * @memberof ics23.CompressedNonExistenceProof\n         * @instance\n         */\n        CompressedNonExistenceProof.prototype.left = null;\n\n        /**\n         * CompressedNonExistenceProof right.\n         * @member {ics23.ICompressedExistenceProof|null|undefined} right\n         * @memberof ics23.CompressedNonExistenceProof\n         * @instance\n         */\n        CompressedNonExistenceProof.prototype.right = null;\n\n        /**\n         * Creates a new CompressedNonExistenceProof instance using the specified properties.\n         * @function create\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {ics23.ICompressedNonExistenceProof=} [properties] Properties to set\n         * @returns {ics23.CompressedNonExistenceProof} CompressedNonExistenceProof instance\n         */\n        CompressedNonExistenceProof.create = function create(properties) {\n            return new CompressedNonExistenceProof(properties);\n        };\n\n        /**\n         * Encodes the specified CompressedNonExistenceProof message. Does not implicitly {@link ics23.CompressedNonExistenceProof.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {ics23.ICompressedNonExistenceProof} message CompressedNonExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedNonExistenceProof.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);\n            if (message.left != null && message.hasOwnProperty(\"left\"))\n                $root.ics23.CompressedExistenceProof.encode(message.left, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            if (message.right != null && message.hasOwnProperty(\"right\"))\n                $root.ics23.CompressedExistenceProof.encode(message.right, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified CompressedNonExistenceProof message, length delimited. Does not implicitly {@link ics23.CompressedNonExistenceProof.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {ics23.ICompressedNonExistenceProof} message CompressedNonExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedNonExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a CompressedNonExistenceProof message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.CompressedNonExistenceProof} CompressedNonExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedNonExistenceProof.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.CompressedNonExistenceProof();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.bytes();\n                    break;\n                case 2:\n                    message.left = $root.ics23.CompressedExistenceProof.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.right = $root.ics23.CompressedExistenceProof.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a CompressedNonExistenceProof message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.CompressedNonExistenceProof} CompressedNonExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedNonExistenceProof.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a CompressedNonExistenceProof message.\n         * @function verify\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        CompressedNonExistenceProof.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                if (!(message.key && typeof message.key.length === \"number\" || $util.isString(message.key)))\n                    return \"key: buffer expected\";\n            if (message.left != null && message.hasOwnProperty(\"left\")) {\n                var error = $root.ics23.CompressedExistenceProof.verify(message.left);\n                if (error)\n                    return \"left.\" + error;\n            }\n            if (message.right != null && message.hasOwnProperty(\"right\")) {\n                var error = $root.ics23.CompressedExistenceProof.verify(message.right);\n                if (error)\n                    return \"right.\" + error;\n            }\n            return null;\n        };\n\n        /**\n         * Creates a CompressedNonExistenceProof message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.CompressedNonExistenceProof} CompressedNonExistenceProof\n         */\n        CompressedNonExistenceProof.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.CompressedNonExistenceProof)\n                return object;\n            var message = new $root.ics23.CompressedNonExistenceProof();\n            if (object.key != null)\n                if (typeof object.key === \"string\")\n                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);\n                else if (object.key.length)\n                    message.key = object.key;\n            if (object.left != null) {\n                if (typeof object.left !== \"object\")\n                    throw TypeError(\".ics23.CompressedNonExistenceProof.left: object expected\");\n                message.left = $root.ics23.CompressedExistenceProof.fromObject(object.left);\n            }\n            if (object.right != null) {\n                if (typeof object.right !== \"object\")\n                    throw TypeError(\".ics23.CompressedNonExistenceProof.right: object expected\");\n                message.right = $root.ics23.CompressedExistenceProof.fromObject(object.right);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a CompressedNonExistenceProof message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {ics23.CompressedNonExistenceProof} message CompressedNonExistenceProof\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        CompressedNonExistenceProof.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                if (options.bytes === String)\n                    object.key = \"\";\n                else {\n                    object.key = [];\n                    if (options.bytes !== Array)\n                        object.key = $util.newBuffer(object.key);\n                }\n                object.left = null;\n                object.right = null;\n            }\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;\n            if (message.left != null && message.hasOwnProperty(\"left\"))\n                object.left = $root.ics23.CompressedExistenceProof.toObject(message.left, options);\n            if (message.right != null && message.hasOwnProperty(\"right\"))\n                object.right = $root.ics23.CompressedExistenceProof.toObject(message.right, options);\n            return object;\n        };\n\n        /**\n         * Converts this CompressedNonExistenceProof to JSON.\n         * @function toJSON\n         * @memberof ics23.CompressedNonExistenceProof\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        CompressedNonExistenceProof.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return CompressedNonExistenceProof;\n    })();\n\n    return ics23;\n})();\n\nmodule.exports = $root;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}