{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decompress = exports.compress = void 0;\n\nconst codecimpl_1 = require(\"./generated/codecimpl\");\n\nfunction compress(proof) {\n  if (!proof.batch) {\n    return proof;\n  }\n\n  return {\n    compressed: compressBatch(proof.batch)\n  };\n}\n\nexports.compress = compress;\n\nfunction decompress(proof) {\n  if (!proof.compressed) {\n    return proof;\n  }\n\n  return {\n    batch: decompressBatch(proof.compressed)\n  };\n}\n\nexports.decompress = decompress;\n\nfunction compressBatch(proof) {\n  const centries = [];\n  const lookup = [];\n  const registry = new Map();\n\n  for (const entry of proof.entries) {\n    if (entry.exist) {\n      const centry = {\n        exist: compressExist(entry.exist, lookup, registry)\n      };\n      centries.push(centry);\n    } else if (entry.nonexist) {\n      const non = entry.nonexist;\n      const centry = {\n        nonexist: {\n          key: non.key,\n          left: compressExist(non.left, lookup, registry),\n          right: compressExist(non.right, lookup, registry)\n        }\n      };\n      centries.push(centry);\n    } else {\n      throw new Error(\"Unexpected batch entry during compress\");\n    }\n  }\n\n  return {\n    entries: centries,\n    lookupInners: lookup\n  };\n}\n\nfunction compressExist(exist, lookup, registry) {\n  if (!exist) {\n    return undefined;\n  }\n\n  const path = exist.path.map(inner => {\n    const sig = codecimpl_1.ics23.InnerOp.encode(inner).finish();\n    let idx = registry.get(sig);\n\n    if (idx === undefined) {\n      idx = lookup.length;\n      lookup.push(inner);\n      registry.set(sig, idx);\n    }\n\n    return idx;\n  });\n  return {\n    key: exist.key,\n    value: exist.value,\n    leaf: exist.leaf,\n    path\n  };\n}\n\nfunction decompressBatch(proof) {\n  const lookup = proof.lookupInners;\n  const entries = proof.entries.map(comp => {\n    if (comp.exist) {\n      return {\n        exist: decompressExist(comp.exist, lookup)\n      };\n    } else if (comp.nonexist) {\n      const non = comp.nonexist;\n      return {\n        nonexist: {\n          key: non.key,\n          left: decompressExist(non.left, lookup),\n          right: decompressExist(non.right, lookup)\n        }\n      };\n    } else {\n      throw new Error(\"Unexpected batch entry during compress\");\n    }\n  });\n  return {\n    entries\n  };\n}\n\nfunction decompressExist(exist, lookup) {\n  if (!exist) {\n    return undefined;\n  }\n\n  const {\n    key,\n    value,\n    leaf,\n    path\n  } = exist;\n  const newPath = (path || []).map(idx => lookup[idx]);\n  return {\n    key,\n    value,\n    leaf,\n    path: newPath\n  };\n}","map":{"version":3,"mappings":"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","names":["compress","proof","batch","compressed","compressBatch","exports","decompress","decompressBatch","centries","lookup","registry","Map","entry","entries","exist","centry","compressExist","push","nonexist","non","key","left","right","Error","lookupInners","undefined","path","map","inner","sig","codecimpl_1","InnerOp","encode","finish","idx","get","length","set","value","leaf","comp","decompressExist","newPath"],"sourceRoot":"","sources":["../src/compress.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}