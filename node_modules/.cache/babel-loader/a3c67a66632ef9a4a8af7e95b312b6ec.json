{"ast":null,"code":"\"use strict\"; // See https://github.com/tendermint/tendermint/blob/f2ada0a604b4c0763bda2f64fac53d506d3beca7/docs/spec/blockchain/encoding.md#public-key-cryptography\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.pubkeyToAddress = exports.pubkeyToRawAddress = exports.rawSecp256k1PubkeyToRawAddress = exports.rawEd25519PubkeyToRawAddress = void 0;\n\nconst crypto_1 = require(\"@cosmjs/crypto\");\n\nconst encoding_1 = require(\"@cosmjs/encoding\");\n\nconst encoding_2 = require(\"./encoding\");\n\nconst pubkeys_1 = require(\"./pubkeys\");\n\nfunction rawEd25519PubkeyToRawAddress(pubkeyData) {\n  if (pubkeyData.length !== 32) {\n    throw new Error(`Invalid Ed25519 pubkey length: ${pubkeyData.length}`);\n  }\n\n  return (0, crypto_1.sha256)(pubkeyData).slice(0, 20);\n}\n\nexports.rawEd25519PubkeyToRawAddress = rawEd25519PubkeyToRawAddress;\n\nfunction rawSecp256k1PubkeyToRawAddress(pubkeyData) {\n  if (pubkeyData.length !== 33) {\n    throw new Error(`Invalid Secp256k1 pubkey length (compressed): ${pubkeyData.length}`);\n  }\n\n  return (0, crypto_1.ripemd160)((0, crypto_1.sha256)(pubkeyData));\n}\n\nexports.rawSecp256k1PubkeyToRawAddress = rawSecp256k1PubkeyToRawAddress; // For secp256k1 this assumes we already have a compressed pubkey.\n\nfunction pubkeyToRawAddress(pubkey) {\n  if ((0, pubkeys_1.isSecp256k1Pubkey)(pubkey)) {\n    const pubkeyData = (0, encoding_1.fromBase64)(pubkey.value);\n    return rawSecp256k1PubkeyToRawAddress(pubkeyData);\n  } else if ((0, pubkeys_1.isEd25519Pubkey)(pubkey)) {\n    const pubkeyData = (0, encoding_1.fromBase64)(pubkey.value);\n    return rawEd25519PubkeyToRawAddress(pubkeyData);\n  } else if ((0, pubkeys_1.isMultisigThresholdPubkey)(pubkey)) {\n    // https://github.com/tendermint/tendermint/blob/38b401657e4ad7a7eeb3c30a3cbf512037df3740/crypto/multisig/threshold_pubkey.go#L71-L74\n    const pubkeyData = (0, encoding_2.encodeAminoPubkey)(pubkey);\n    return (0, crypto_1.sha256)(pubkeyData).slice(0, 20);\n  } else {\n    throw new Error(\"Unsupported public key type\");\n  }\n}\n\nexports.pubkeyToRawAddress = pubkeyToRawAddress;\n\nfunction pubkeyToAddress(pubkey, prefix) {\n  return (0, encoding_1.toBech32)(prefix, pubkeyToRawAddress(pubkey));\n}\n\nexports.pubkeyToAddress = pubkeyToAddress;","map":{"version":3,"mappings":"cAAA;;;;;;;AAEA;;AACA;;AAEA;;AACA;;AAEA,SAAgBA,4BAAhB,CAA6CC,UAA7C,EAAmE;EACjE,IAAIA,UAAU,CAACC,MAAX,KAAsB,EAA1B,EAA8B;IAC5B,MAAM,IAAIC,KAAJ,CAAU,kCAAkCF,UAAU,CAACC,MAAM,EAA7D,CAAN;EACD;;EACD,OAAO,qBAAOD,UAAP,EAAmBG,KAAnB,CAAyB,CAAzB,EAA4B,EAA5B,CAAP;AACD;;AALDC;;AAOA,SAAgBC,8BAAhB,CAA+CL,UAA/C,EAAqE;EACnE,IAAIA,UAAU,CAACC,MAAX,KAAsB,EAA1B,EAA8B;IAC5B,MAAM,IAAIC,KAAJ,CAAU,iDAAiDF,UAAU,CAACC,MAAM,EAA5E,CAAN;EACD;;EACD,OAAO,wBAAU,qBAAOD,UAAP,CAAV,CAAP;AACD;;AALDI,wE,CAOA;;AACA,SAAgBE,kBAAhB,CAAmCC,MAAnC,EAAiD;EAC/C,IAAI,iCAAkBA,MAAlB,CAAJ,EAA+B;IAC7B,MAAMP,UAAU,GAAG,2BAAWO,MAAM,CAACC,KAAlB,CAAnB;IACA,OAAOH,8BAA8B,CAACL,UAAD,CAArC;EACD,CAHD,MAGO,IAAI,+BAAgBO,MAAhB,CAAJ,EAA6B;IAClC,MAAMP,UAAU,GAAG,2BAAWO,MAAM,CAACC,KAAlB,CAAnB;IACA,OAAOT,4BAA4B,CAACC,UAAD,CAAnC;EACD,CAHM,MAGA,IAAI,yCAA0BO,MAA1B,CAAJ,EAAuC;IAC5C;IACA,MAAMP,UAAU,GAAG,kCAAkBO,MAAlB,CAAnB;IACA,OAAO,qBAAOP,UAAP,EAAmBG,KAAnB,CAAyB,CAAzB,EAA4B,EAA5B,CAAP;EACD,CAJM,MAIA;IACL,MAAM,IAAID,KAAJ,CAAU,6BAAV,CAAN;EACD;AACF;;AAdDE;;AAgBA,SAAgBK,eAAhB,CAAgCF,MAAhC,EAAgDG,MAAhD,EAA8D;EAC5D,OAAO,yBAASA,MAAT,EAAiBJ,kBAAkB,CAACC,MAAD,CAAnC,CAAP;AACD;;AAFDH","names":["rawEd25519PubkeyToRawAddress","pubkeyData","length","Error","slice","exports","rawSecp256k1PubkeyToRawAddress","pubkeyToRawAddress","pubkey","value","pubkeyToAddress","prefix"],"sourceRoot":"","sources":["../src/addresses.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}