{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.QueueingStreamingSocket = exports.ConnectionStatus = void 0;\n\nconst stream_1 = require(\"@cosmjs/stream\");\n\nconst xstream_1 = require(\"xstream\");\n\nconst streamingsocket_1 = require(\"./streamingsocket\");\n\nvar ConnectionStatus;\n\n(function (ConnectionStatus) {\n  ConnectionStatus[ConnectionStatus[\"Unconnected\"] = 0] = \"Unconnected\";\n  ConnectionStatus[ConnectionStatus[\"Connecting\"] = 1] = \"Connecting\";\n  ConnectionStatus[ConnectionStatus[\"Connected\"] = 2] = \"Connected\";\n  ConnectionStatus[ConnectionStatus[\"Disconnected\"] = 3] = \"Disconnected\";\n})(ConnectionStatus = exports.ConnectionStatus || (exports.ConnectionStatus = {}));\n/**\n * A wrapper around StreamingSocket that can queue requests.\n */\n\n\nclass QueueingStreamingSocket {\n  constructor(url) {\n    let timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10000;\n    let reconnectedHandler = arguments.length > 2 ? arguments[2] : undefined;\n    this.queue = [];\n    this.isProcessingQueue = false;\n    this.url = url;\n    this.timeout = timeout;\n    this.reconnectedHandler = reconnectedHandler;\n    const eventProducer = {\n      start: listener => this.eventProducerListener = listener,\n      stop: () => this.eventProducerListener = undefined\n    };\n    this.events = xstream_1.Stream.create(eventProducer);\n    this.connectionStatusProducer = new stream_1.DefaultValueProducer(ConnectionStatus.Unconnected);\n    this.connectionStatus = new stream_1.ValueAndUpdates(this.connectionStatusProducer);\n    this.socket = new streamingsocket_1.StreamingSocket(this.url, this.timeout);\n    this.socket.events.subscribe({\n      next: event => {\n        if (!this.eventProducerListener) throw new Error(\"No event producer listener set\");\n        this.eventProducerListener.next(event);\n      },\n      error: () => this.connectionStatusProducer.update(ConnectionStatus.Disconnected)\n    });\n  }\n\n  connect() {\n    this.connectionStatusProducer.update(ConnectionStatus.Connecting);\n    this.socket.connected.then(async () => {\n      this.connectionStatusProducer.update(ConnectionStatus.Connected);\n      return this.processQueue();\n    }, () => this.connectionStatusProducer.update(ConnectionStatus.Disconnected));\n    this.socket.connect();\n  }\n\n  disconnect() {\n    this.connectionStatusProducer.update(ConnectionStatus.Disconnected);\n    this.socket.disconnect();\n  }\n\n  reconnect() {\n    this.socket = new streamingsocket_1.StreamingSocket(this.url, this.timeout);\n    this.socket.events.subscribe({\n      next: event => {\n        if (!this.eventProducerListener) throw new Error(\"No event producer listener set\");\n        this.eventProducerListener.next(event);\n      },\n      error: () => this.connectionStatusProducer.update(ConnectionStatus.Disconnected)\n    }); // eslint-disable-next-line @typescript-eslint/no-floating-promises\n\n    this.socket.connected.then(() => {\n      if (this.reconnectedHandler) {\n        this.reconnectedHandler();\n      }\n    });\n    this.connect();\n  }\n\n  getQueueLength() {\n    return this.queue.length;\n  }\n\n  queueRequest(request) {\n    this.queue.push(request); // We donâ€™t need to wait for the queue to be processed.\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n\n    this.processQueue();\n  }\n\n  async processQueue() {\n    if (this.isProcessingQueue || this.connectionStatus.value !== ConnectionStatus.Connected) {\n      return;\n    }\n\n    this.isProcessingQueue = true;\n    let request;\n\n    while (request = this.queue.shift()) {\n      try {\n        await this.socket.send(request);\n        this.isProcessingQueue = false;\n      } catch (error) {\n        // Probably the connection is down; will try again automatically when reconnected.\n        this.queue.unshift(request);\n        this.isProcessingQueue = false;\n        return;\n      }\n    }\n  }\n\n}\n\nexports.QueueingStreamingSocket = QueueingStreamingSocket;","map":{"version":3,"mappings":"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","names":["ConnectionStatus","exports","QueueingStreamingSocket","constructor","url","timeout","reconnectedHandler","eventProducer","start","listener","eventProducerListener","stop","undefined","events","xstream_1","create","connectionStatusProducer","stream_1","Unconnected","connectionStatus","socket","streamingsocket_1","subscribe","next","event","Error","error","update","Disconnected","connect","Connecting","connected","then","Connected","processQueue","disconnect","reconnect","getQueueLength","queue","length","queueRequest","request","push","isProcessingQueue","value","shift","send","unshift"],"sourceRoot":"","sources":["../src/queueingstreamingsocket.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}