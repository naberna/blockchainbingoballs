{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fromHex = exports.toHex = void 0;\n\nfunction toHex(data) {\n  let out = \"\";\n\n  for (const byte of data) {\n    out += (\"0\" + byte.toString(16)).slice(-2);\n  }\n\n  return out;\n}\n\nexports.toHex = toHex;\n\nfunction fromHex(hexstring) {\n  if (hexstring.length % 2 !== 0) {\n    throw new Error(\"hex string length must be a multiple of 2\");\n  }\n\n  const out = new Uint8Array(hexstring.length / 2);\n\n  for (let i = 0; i < out.length; i++) {\n    const j = 2 * i;\n    const hexByteAsString = hexstring.slice(j, j + 2);\n\n    if (!hexByteAsString.match(/[0-9a-f]{2}/i)) {\n      throw new Error(\"hex string contains invalid characters\");\n    }\n\n    out[i] = parseInt(hexByteAsString, 16);\n  }\n\n  return out;\n}\n\nexports.fromHex = fromHex;","map":{"version":3,"mappings":";;;;;;;AAAA,SAAgBA,KAAhB,CAAsBC,IAAtB,EAAsC;EACpC,IAAIC,GAAG,GAAG,EAAV;;EACA,KAAK,MAAMC,IAAX,IAAmBF,IAAnB,EAAyB;IACvBC,GAAG,IAAI,CAAC,MAAMC,IAAI,CAACC,QAAL,CAAc,EAAd,CAAP,EAA0BC,KAA1B,CAAgC,CAAC,CAAjC,CAAP;EACD;;EACD,OAAOH,GAAP;AACD;;AANDI;;AAQA,SAAgBC,OAAhB,CAAwBC,SAAxB,EAAyC;EACvC,IAAIA,SAAS,CAACC,MAAV,GAAmB,CAAnB,KAAyB,CAA7B,EAAgC;IAC9B,MAAM,IAAIC,KAAJ,CAAU,2CAAV,CAAN;EACD;;EAED,MAAMR,GAAG,GAAG,IAAIS,UAAJ,CAAeH,SAAS,CAACC,MAAV,GAAmB,CAAlC,CAAZ;;EACA,KAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGV,GAAG,CAACO,MAAxB,EAAgCG,CAAC,EAAjC,EAAqC;IACnC,MAAMC,CAAC,GAAG,IAAID,CAAd;IACA,MAAME,eAAe,GAAGN,SAAS,CAACH,KAAV,CAAgBQ,CAAhB,EAAmBA,CAAC,GAAG,CAAvB,CAAxB;;IACA,IAAI,CAACC,eAAe,CAACC,KAAhB,CAAsB,cAAtB,CAAL,EAA4C;MAC1C,MAAM,IAAIL,KAAJ,CAAU,wCAAV,CAAN;IACD;;IACDR,GAAG,CAACU,CAAD,CAAH,GAASI,QAAQ,CAACF,eAAD,EAAkB,EAAlB,CAAjB;EACD;;EACD,OAAOZ,GAAP;AACD;;AAfDI","names":["toHex","data","out","byte","toString","slice","exports","fromHex","hexstring","length","Error","Uint8Array","i","j","hexByteAsString","match","parseInt"],"sourceRoot":"","sources":["../src/hex.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}