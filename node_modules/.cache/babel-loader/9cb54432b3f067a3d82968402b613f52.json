{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ExtendedSecp256k1Signature = exports.Secp256k1Signature = void 0;\n\nfunction trimLeadingNullBytes(inData) {\n  let numberOfLeadingNullBytes = 0;\n\n  for (const byte of inData) {\n    if (byte === 0x00) {\n      numberOfLeadingNullBytes++;\n    } else {\n      break;\n    }\n  }\n\n  return inData.slice(numberOfLeadingNullBytes);\n}\n\nconst derTagInteger = 0x02;\n\nclass Secp256k1Signature {\n  constructor(r, s) {\n    if (r.length > 32 || r.length === 0 || r[0] === 0x00) {\n      throw new Error(\"Unsigned integer r must be encoded as unpadded big endian.\");\n    }\n\n    if (s.length > 32 || s.length === 0 || s[0] === 0x00) {\n      throw new Error(\"Unsigned integer s must be encoded as unpadded big endian.\");\n    }\n\n    this.data = {\n      r: r,\n      s: s\n    };\n  }\n  /**\n   * Takes the pair of integers (r, s) as 2x32 byte of binary data.\n   *\n   * Note: This is the format Cosmos SDK uses natively.\n   *\n   * @param data a 64 byte value containing integers r and s.\n   */\n\n\n  static fromFixedLength(data) {\n    if (data.length !== 64) {\n      throw new Error(`Got invalid data length: ${data.length}. Expected 2x 32 bytes for the pair (r, s)`);\n    }\n\n    return new Secp256k1Signature(trimLeadingNullBytes(data.slice(0, 32)), trimLeadingNullBytes(data.slice(32, 64)));\n  }\n\n  static fromDer(data) {\n    let pos = 0;\n\n    if (data[pos++] !== 0x30) {\n      throw new Error(\"Prefix 0x30 expected\");\n    }\n\n    const bodyLength = data[pos++];\n\n    if (data.length - pos !== bodyLength) {\n      throw new Error(\"Data length mismatch detected\");\n    } // r\n\n\n    const rTag = data[pos++];\n\n    if (rTag !== derTagInteger) {\n      throw new Error(\"INTEGER tag expected\");\n    }\n\n    const rLength = data[pos++];\n\n    if (rLength >= 0x80) {\n      throw new Error(\"Decoding length values above 127 not supported\");\n    }\n\n    const rData = data.slice(pos, pos + rLength);\n    pos += rLength; // s\n\n    const sTag = data[pos++];\n\n    if (sTag !== derTagInteger) {\n      throw new Error(\"INTEGER tag expected\");\n    }\n\n    const sLength = data[pos++];\n\n    if (sLength >= 0x80) {\n      throw new Error(\"Decoding length values above 127 not supported\");\n    }\n\n    const sData = data.slice(pos, pos + sLength);\n    pos += sLength;\n    return new Secp256k1Signature( // r/s data can contain leading 0 bytes to express integers being non-negative in DER\n    trimLeadingNullBytes(rData), trimLeadingNullBytes(sData));\n  }\n\n  r(length) {\n    if (length === undefined) {\n      return this.data.r;\n    } else {\n      const paddingLength = length - this.data.r.length;\n\n      if (paddingLength < 0) {\n        throw new Error(\"Length too small to hold parameter r\");\n      }\n\n      const padding = new Uint8Array(paddingLength);\n      return new Uint8Array([...padding, ...this.data.r]);\n    }\n  }\n\n  s(length) {\n    if (length === undefined) {\n      return this.data.s;\n    } else {\n      const paddingLength = length - this.data.s.length;\n\n      if (paddingLength < 0) {\n        throw new Error(\"Length too small to hold parameter s\");\n      }\n\n      const padding = new Uint8Array(paddingLength);\n      return new Uint8Array([...padding, ...this.data.s]);\n    }\n  }\n\n  toFixedLength() {\n    return new Uint8Array([...this.r(32), ...this.s(32)]);\n  }\n\n  toDer() {\n    // DER supports negative integers but our data is unsigned. Thus we need to prepend\n    // a leading 0 byte when the higest bit is set to differentiate nagative values\n    const rEncoded = this.data.r[0] >= 0x80 ? new Uint8Array([0, ...this.data.r]) : this.data.r;\n    const sEncoded = this.data.s[0] >= 0x80 ? new Uint8Array([0, ...this.data.s]) : this.data.s;\n    const rLength = rEncoded.length;\n    const sLength = sEncoded.length;\n    const data = new Uint8Array([derTagInteger, rLength, ...rEncoded, derTagInteger, sLength, ...sEncoded]);\n    return new Uint8Array([0x30, data.length, ...data]);\n  }\n\n}\n\nexports.Secp256k1Signature = Secp256k1Signature;\n/**\n * A Secp256k1Signature plus the recovery parameter\n */\n\nclass ExtendedSecp256k1Signature extends Secp256k1Signature {\n  constructor(r, s, recovery) {\n    super(r, s);\n\n    if (!Number.isInteger(recovery)) {\n      throw new Error(\"The recovery parameter must be an integer.\");\n    }\n\n    if (recovery < 0 || recovery > 4) {\n      throw new Error(\"The recovery parameter must be one of 0, 1, 2, 3.\");\n    }\n\n    this.recovery = recovery;\n  }\n  /**\n   * Decode extended signature from the simple fixed length encoding\n   * described in toFixedLength().\n   */\n\n\n  static fromFixedLength(data) {\n    if (data.length !== 65) {\n      throw new Error(`Got invalid data length ${data.length}. Expected 32 + 32 + 1`);\n    }\n\n    return new ExtendedSecp256k1Signature(trimLeadingNullBytes(data.slice(0, 32)), trimLeadingNullBytes(data.slice(32, 64)), data[64]);\n  }\n  /**\n   * A simple custom encoding that encodes the extended signature as\n   * r (32 bytes) | s (32 bytes) | recovery param (1 byte)\n   * where | denotes concatenation of bonary data.\n   */\n\n\n  toFixedLength() {\n    return new Uint8Array([...this.r(32), ...this.s(32), this.recovery]);\n  }\n\n}\n\nexports.ExtendedSecp256k1Signature = ExtendedSecp256k1Signature;","map":{"version":3,"mappings":";;;;;;;AAAA,SAASA,oBAAT,CAA8BC,MAA9B,EAAgD;EAC9C,IAAIC,wBAAwB,GAAG,CAA/B;;EACA,KAAK,MAAMC,IAAX,IAAmBF,MAAnB,EAA2B;IACzB,IAAIE,IAAI,KAAK,IAAb,EAAmB;MACjBD,wBAAwB;IACzB,CAFD,MAEO;MACL;IACD;EACF;;EACD,OAAOD,MAAM,CAACG,KAAP,CAAaF,wBAAb,CAAP;AACD;;AAED,MAAMG,aAAa,GAAG,IAAtB;;AAEA,MAAaC,kBAAb,CAA+B;EAkE7BC,YAAmBC,CAAnB,EAAkCC,CAAlC,EAA+C;IAC7C,IAAID,CAAC,CAACE,MAAF,GAAW,EAAX,IAAiBF,CAAC,CAACE,MAAF,KAAa,CAA9B,IAAmCF,CAAC,CAAC,CAAD,CAAD,KAAS,IAAhD,EAAsD;MACpD,MAAM,IAAIG,KAAJ,CAAU,4DAAV,CAAN;IACD;;IAED,IAAIF,CAAC,CAACC,MAAF,GAAW,EAAX,IAAiBD,CAAC,CAACC,MAAF,KAAa,CAA9B,IAAmCD,CAAC,CAAC,CAAD,CAAD,KAAS,IAAhD,EAAsD;MACpD,MAAM,IAAIE,KAAJ,CAAU,4DAAV,CAAN;IACD;;IAED,KAAKC,IAAL,GAAY;MACVJ,CAAC,EAAEA,CADO;MAEVC,CAAC,EAAEA;IAFO,CAAZ;EAID;EA9ED;;;;;;;;;EAO6B,OAAfI,eAAe,CAACD,IAAD,EAAiB;IAC5C,IAAIA,IAAI,CAACF,MAAL,KAAgB,EAApB,EAAwB;MACtB,MAAM,IAAIC,KAAJ,CAAU,4BAA4BC,IAAI,CAACF,MAAM,4CAAjD,CAAN;IACD;;IACD,OAAO,IAAIJ,kBAAJ,CACLN,oBAAoB,CAACY,IAAI,CAACR,KAAL,CAAW,CAAX,EAAc,EAAd,CAAD,CADf,EAELJ,oBAAoB,CAACY,IAAI,CAACR,KAAL,CAAW,EAAX,EAAe,EAAf,CAAD,CAFf,CAAP;EAID;;EAEoB,OAAPU,OAAO,CAACF,IAAD,EAAiB;IACpC,IAAIG,GAAG,GAAG,CAAV;;IAEA,IAAIH,IAAI,CAACG,GAAG,EAAJ,CAAJ,KAAgB,IAApB,EAA0B;MACxB,MAAM,IAAIJ,KAAJ,CAAU,sBAAV,CAAN;IACD;;IAED,MAAMK,UAAU,GAAGJ,IAAI,CAACG,GAAG,EAAJ,CAAvB;;IACA,IAAIH,IAAI,CAACF,MAAL,GAAcK,GAAd,KAAsBC,UAA1B,EAAsC;MACpC,MAAM,IAAIL,KAAJ,CAAU,+BAAV,CAAN;IACD,CAVmC,CAYpC;;;IACA,MAAMM,IAAI,GAAGL,IAAI,CAACG,GAAG,EAAJ,CAAjB;;IACA,IAAIE,IAAI,KAAKZ,aAAb,EAA4B;MAC1B,MAAM,IAAIM,KAAJ,CAAU,sBAAV,CAAN;IACD;;IACD,MAAMO,OAAO,GAAGN,IAAI,CAACG,GAAG,EAAJ,CAApB;;IACA,IAAIG,OAAO,IAAI,IAAf,EAAqB;MACnB,MAAM,IAAIP,KAAJ,CAAU,gDAAV,CAAN;IACD;;IACD,MAAMQ,KAAK,GAAGP,IAAI,CAACR,KAAL,CAAWW,GAAX,EAAgBA,GAAG,GAAGG,OAAtB,CAAd;IACAH,GAAG,IAAIG,OAAP,CAtBoC,CAwBpC;;IACA,MAAME,IAAI,GAAGR,IAAI,CAACG,GAAG,EAAJ,CAAjB;;IACA,IAAIK,IAAI,KAAKf,aAAb,EAA4B;MAC1B,MAAM,IAAIM,KAAJ,CAAU,sBAAV,CAAN;IACD;;IACD,MAAMU,OAAO,GAAGT,IAAI,CAACG,GAAG,EAAJ,CAApB;;IACA,IAAIM,OAAO,IAAI,IAAf,EAAqB;MACnB,MAAM,IAAIV,KAAJ,CAAU,gDAAV,CAAN;IACD;;IACD,MAAMW,KAAK,GAAGV,IAAI,CAACR,KAAL,CAAWW,GAAX,EAAgBA,GAAG,GAAGM,OAAtB,CAAd;IACAN,GAAG,IAAIM,OAAP;IAEA,OAAO,IAAIf,kBAAJ,EACL;IACAN,oBAAoB,CAACmB,KAAD,CAFf,EAGLnB,oBAAoB,CAACsB,KAAD,CAHf,CAAP;EAKD;;EAsBMd,CAAC,CAACE,MAAD,EAAgB;IACtB,IAAIA,MAAM,KAAKa,SAAf,EAA0B;MACxB,OAAO,KAAKX,IAAL,CAAUJ,CAAjB;IACD,CAFD,MAEO;MACL,MAAMgB,aAAa,GAAGd,MAAM,GAAG,KAAKE,IAAL,CAAUJ,CAAV,CAAYE,MAA3C;;MACA,IAAIc,aAAa,GAAG,CAApB,EAAuB;QACrB,MAAM,IAAIb,KAAJ,CAAU,sCAAV,CAAN;MACD;;MACD,MAAMc,OAAO,GAAG,IAAIC,UAAJ,CAAeF,aAAf,CAAhB;MACA,OAAO,IAAIE,UAAJ,CAAe,CAAC,GAAGD,OAAJ,EAAa,GAAG,KAAKb,IAAL,CAAUJ,CAA1B,CAAf,CAAP;IACD;EACF;;EAEMC,CAAC,CAACC,MAAD,EAAgB;IACtB,IAAIA,MAAM,KAAKa,SAAf,EAA0B;MACxB,OAAO,KAAKX,IAAL,CAAUH,CAAjB;IACD,CAFD,MAEO;MACL,MAAMe,aAAa,GAAGd,MAAM,GAAG,KAAKE,IAAL,CAAUH,CAAV,CAAYC,MAA3C;;MACA,IAAIc,aAAa,GAAG,CAApB,EAAuB;QACrB,MAAM,IAAIb,KAAJ,CAAU,sCAAV,CAAN;MACD;;MACD,MAAMc,OAAO,GAAG,IAAIC,UAAJ,CAAeF,aAAf,CAAhB;MACA,OAAO,IAAIE,UAAJ,CAAe,CAAC,GAAGD,OAAJ,EAAa,GAAG,KAAKb,IAAL,CAAUH,CAA1B,CAAf,CAAP;IACD;EACF;;EAEMkB,aAAa;IAClB,OAAO,IAAID,UAAJ,CAAe,CAAC,GAAG,KAAKlB,CAAL,CAAO,EAAP,CAAJ,EAAgB,GAAG,KAAKC,CAAL,CAAO,EAAP,CAAnB,CAAf,CAAP;EACD;;EAEMmB,KAAK;IACV;IACA;IACA,MAAMC,QAAQ,GAAG,KAAKjB,IAAL,CAAUJ,CAAV,CAAY,CAAZ,KAAkB,IAAlB,GAAyB,IAAIkB,UAAJ,CAAe,CAAC,CAAD,EAAI,GAAG,KAAKd,IAAL,CAAUJ,CAAjB,CAAf,CAAzB,GAA+D,KAAKI,IAAL,CAAUJ,CAA1F;IACA,MAAMsB,QAAQ,GAAG,KAAKlB,IAAL,CAAUH,CAAV,CAAY,CAAZ,KAAkB,IAAlB,GAAyB,IAAIiB,UAAJ,CAAe,CAAC,CAAD,EAAI,GAAG,KAAKd,IAAL,CAAUH,CAAjB,CAAf,CAAzB,GAA+D,KAAKG,IAAL,CAAUH,CAA1F;IAEA,MAAMS,OAAO,GAAGW,QAAQ,CAACnB,MAAzB;IACA,MAAMW,OAAO,GAAGS,QAAQ,CAACpB,MAAzB;IACA,MAAME,IAAI,GAAG,IAAIc,UAAJ,CAAe,CAACrB,aAAD,EAAgBa,OAAhB,EAAyB,GAAGW,QAA5B,EAAsCxB,aAAtC,EAAqDgB,OAArD,EAA8D,GAAGS,QAAjE,CAAf,CAAb;IAEA,OAAO,IAAIJ,UAAJ,CAAe,CAAC,IAAD,EAAOd,IAAI,CAACF,MAAZ,EAAoB,GAAGE,IAAvB,CAAf,CAAP;EACD;;AA1H4B;;AAA/BmB;AA6HA;;;;AAGA,MAAaC,0BAAb,SAAgD1B,kBAAhD,CAAkE;EAkBhEC,YAAmBC,CAAnB,EAAkCC,CAAlC,EAAiDwB,QAAjD,EAAiE;IAC/D,MAAMzB,CAAN,EAASC,CAAT;;IAEA,IAAI,CAACyB,MAAM,CAACC,SAAP,CAAiBF,QAAjB,CAAL,EAAiC;MAC/B,MAAM,IAAItB,KAAJ,CAAU,4CAAV,CAAN;IACD;;IAED,IAAIsB,QAAQ,GAAG,CAAX,IAAgBA,QAAQ,GAAG,CAA/B,EAAkC;MAChC,MAAM,IAAItB,KAAJ,CAAU,mDAAV,CAAN;IACD;;IAED,KAAKsB,QAAL,GAAgBA,QAAhB;EACD;EA7BD;;;;;;EAIsC,OAAfpB,eAAe,CAACD,IAAD,EAAiB;IACrD,IAAIA,IAAI,CAACF,MAAL,KAAgB,EAApB,EAAwB;MACtB,MAAM,IAAIC,KAAJ,CAAU,2BAA2BC,IAAI,CAACF,MAAM,wBAAhD,CAAN;IACD;;IACD,OAAO,IAAIsB,0BAAJ,CACLhC,oBAAoB,CAACY,IAAI,CAACR,KAAL,CAAW,CAAX,EAAc,EAAd,CAAD,CADf,EAELJ,oBAAoB,CAACY,IAAI,CAACR,KAAL,CAAW,EAAX,EAAe,EAAf,CAAD,CAFf,EAGLQ,IAAI,CAAC,EAAD,CAHC,CAAP;EAKD;EAkBD;;;;;;;EAKgBe,aAAa;IAC3B,OAAO,IAAID,UAAJ,CAAe,CAAC,GAAG,KAAKlB,CAAL,CAAO,EAAP,CAAJ,EAAgB,GAAG,KAAKC,CAAL,CAAO,EAAP,CAAnB,EAA+B,KAAKwB,QAApC,CAAf,CAAP;EACD;;AAvC+D;;AAAlEF","names":["trimLeadingNullBytes","inData","numberOfLeadingNullBytes","byte","slice","derTagInteger","Secp256k1Signature","constructor","r","s","length","Error","data","fromFixedLength","fromDer","pos","bodyLength","rTag","rLength","rData","sTag","sLength","sData","undefined","paddingLength","padding","Uint8Array","toFixedLength","toDer","rEncoded","sEncoded","exports","ExtendedSecp256k1Signature","recovery","Number","isInteger"],"sourceRoot":"","sources":["../src/secp256k1signature.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}